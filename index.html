<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Made on Vibes DIY</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet" />
    <link rel="icon" type="image/svg+xml" href="/assets/icons/favicon.svg" />
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png" />
    <link rel="icon" type="image/x-icon" href="/assets/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png" />
    <link rel="manifest" href="/assets/icons/site.webmanifest" />
    <meta name="theme-color" content="#FFD600" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Julian" />
    <script>globalThis.process = { env: { NODE_ENV: "production" } };</script>
    <script>
      // One-time IndexedDB wipe: clear corrupted Fireproof CRDT state.
      // Fireproof names its IDB databases after the ledger (e.g. "julian-chat-v2.data"),
      // not with a "fireproof" prefix. Wipe all IDB databases on version bump.
      // Bump DB_VERSION to re-trigger if corruption recurs.
      (function() {
        var DB_VERSION = 6;
        var KEY = 'fp_migration_v' + DB_VERSION;
        if (localStorage.getItem(KEY)) return;
        var dbs = indexedDB.databases ? indexedDB.databases() : Promise.resolve([]);
        dbs.then(function(databases) {
          if (databases.length === 0) {
            localStorage.setItem(KEY, Date.now());
            return;
          }
          var deleted = 0;
          databases.forEach(function(db) {
            var req = indexedDB.deleteDatabase(db.name);
            req.onsuccess = req.onerror = function() {
              deleted++;
              if (deleted === databases.length) {
                localStorage.setItem(KEY, Date.now());
                location.reload();
              }
            };
          });
        }).catch(function() {
          localStorage.setItem(KEY, Date.now());
        });
      })();
    </script>
    <script src="https://unpkg.com/@babel/standalone@7.26.0/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- JulianScreen client modules (must load in order: renderer creates window.JScreen, others attach to it) -->
    <script src="/julianscreen/client/renderer.js"></script>
    <script src="/julianscreen/client/sprites.js"></script>
    <script src="/julianscreen/client/tiles.js"></script>
    <script src="/julianscreen/client/text.js"></script>
    <script src="/julianscreen/client/input.js"></script>
    <script src="/julianscreen/client/effects.js"></script>
    <script src="/julianscreen/client/face.js"></script>
    <script src="/julianscreen/client/menu.js"></script>
    <script>
      // ── SoundManager singleton ─────────────────────────────────────────
      // Plain JS, no React. Lives on window.SFX for global access.
      // Follows the same pattern as JulianScreenWS — script-scope singleton.
      (function() {
        var SOUNDS = [
          'boot','shutdown','level-up','click','notification','success',
          'error','open','close','select','navigate','tab',
          'toggle-on','toggle-off','delete'
        ];
        function SoundManager(basePath) {
          this._muted = localStorage.getItem('julian-sfx-muted') === 'true';
          this._sounds = {};
          for (var i = 0; i < SOUNDS.length; i++) {
            var audio = new Audio(basePath + SOUNDS[i] + '.mp3');
            audio.preload = 'auto';
            audio.volume = 0.4;
            this._sounds[SOUNDS[i]] = audio;
          }
        }
        SoundManager.prototype.play = function(name) {
          if (this._muted) return;
          var source = this._sounds[name];
          if (!source) return;
          var clone = source.cloneNode();
          clone.volume = source.volume;
          clone.play().catch(function() {});
        };
        SoundManager.prototype.mute = function() {
          this._muted = !this._muted;
          localStorage.setItem('julian-sfx-muted', String(this._muted));
          document.dispatchEvent(new CustomEvent('julian-sfx-mute-changed', {
            detail: { muted: this._muted }
          }));
          return this._muted;
        };
        Object.defineProperty(SoundManager.prototype, 'isMuted', {
          get: function() { return this._muted; }
        });
        // Boot sound — plays once per page load, requires user gesture
        SoundManager.prototype.playBoot = function() {
          if (this._bootPlayed) return;
          this._bootPlayed = true;
          this.play('boot');
        };
        window.SFX = new SoundManager('/sfx/');
      })();
    </script>
    <style>
      :root {
        /* Core colors */
        --vibes-black: #0f172a;
        --vibes-white: #ffffff;
        --vibes-near-black: #1a1a1a;
        --vibes-cream: #fffff0;

        /* Gray scale */
        --vibes-gray-lightest: #f1f5f9;
        --vibes-gray-ultralight: #f8fafc;
        --vibes-gray-mid: #555555;

        /* Menu colors */
        --vibes-menu-bg: #CCCDC8;
        --vibes-menu-grid: rgba(255, 255, 255, 0.5);

        /* Button variant colors */
        --vibes-variant-blue: #009ACE;
        --vibes-variant-red: #DA291C;
        --vibes-variant-yellow: #eab308;
        --vibes-variant-gray: #6b7280;

        /* Button styling */
        --vibes-button-bg: var(--vibes-cream);
        --vibes-button-text: var(--vibes-near-black);
        --vibes-button-border: var(--vibes-near-black);
        --vibes-button-icon-bg: #fff;
        --vibes-button-icon-fill: #2a2a2a;

        /* Dark-aware button variants (for components using ignoreDarkMode=false) */
        --vibes-button-bg-dark-aware: var(--vibes-cream);
        --vibes-button-text-dark-aware: var(--vibes-near-black);
        --vibes-button-border-dark-aware: var(--vibes-near-black);
        --vibes-button-icon-bg-dark-aware: var(--vibes-white);

        /* Card colors */
        --vibes-card-bg: var(--vibes-cream);
        --vibes-card-text: var(--vibes-near-black);
        --vibes-card-border: var(--vibes-near-black);

        /* Status colors */
        --vibes-green: #22c55e;
        --vibes-red-accent: #ef4444;
        --vibes-yellow-accent: #eab308;
        --vibes-shadow-color: rgba(0, 0, 0, 0.2);

        /* Text colors */
        --vibes-text-primary: var(--vibes-near-black);

        /* Landing page theming (customize these for brand) */
        --landing-accent: #0f172a;
        --landing-accent-hover: #1e293b;

        /* Admin dashboard theming */
        --admin-bg: oklch(0.97 0.01 250);
        --admin-card-bg: white;
        --admin-text: #0f172a;
        --admin-text-muted: #64748b;
        --admin-accent: oklch(0.6 0.2 145);
        --admin-border: #0f172a;
        --admin-shadow: #0f172a;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --vibes-button-bg-dark-aware: #2a2a2a;
          --vibes-button-text-dark-aware: var(--vibes-gray-ultralight);
          --vibes-button-border-dark-aware: var(--vibes-gray-mid);
          --vibes-button-icon-bg-dark-aware: #404040;
        }
      }


      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      }
      #container {
        width: 100%;
        height: 100vh;
      }

      /* ── Screen panel design system ─────────────────────────────────────── */
      @keyframes screen-icon-glow {
        0%, 100% { filter: drop-shadow(0 0 2px rgba(250, 214, 1, 0.3)); }
        50% { filter: drop-shadow(0 0 4px rgba(250, 214, 1, 0.5)); }
      }
      .screen-icon-glow {
        animation: screen-icon-glow 3s ease-in-out infinite;
      }
      .screen-grid-item:hover .screen-icon-glow {
        opacity: 1 !important;
        transform: scale(1.05);
      }
      .screen-grid-item:hover .screen-grid-label {
        color: white !important;
      }
      .screen-panel-scroll::-webkit-scrollbar {
        width: 6px;
        background: #0c0c0c;
      }
      .screen-panel-scroll::-webkit-scrollbar-track {
        background-color: transparent;
      }
      .screen-panel-scroll::-webkit-scrollbar-thumb {
        background-color: #333;
        border-radius: 3px;
      }
      .screen-panel-scroll::-webkit-scrollbar-button {
        display: none;
      }

      /* ── Button press feedback ─────────────────────────────────────────── */
      button {
        touch-action: manipulation;
      }
      button:active {
        transform: scale(0.97);
      }

      /* ── Message entrance animation ────────────────────────────────────── */
      @keyframes message-enter {
        from { opacity: 0; transform: translateY(8px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .message-enter {
        animation: message-enter 200ms cubic-bezier(0.165, 0.84, 0.44, 1);
      }

      /* ── Reduced motion ────────────────────────────────────────────────── */
      @media (prefers-reduced-motion: reduce) {
        .screen-icon-glow { animation: none; }
        .screen-grid-item:hover .screen-icon-glow { transform: none; }
        .message-enter { animation: none; }
        button:active { transform: none; }
      }

      /* ── Hover effects only on hover-capable devices ───────────────────── */
      .screen-grid-item:hover .screen-icon-glow,
      .screen-grid-item:hover .screen-grid-label {
        /* Default: already defined above */
      }
      @media (hover: none) {
        .screen-grid-item:hover .screen-icon-glow {
          opacity: 0.8 !important;
          transform: none;
        }
        .screen-grid-item:hover .screen-grid-label {
          color: rgba(255,255,255,0.4) !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/stable/react@19.2.4",
          "react/jsx-runtime": "https://esm.sh/stable/react@19.2.4/jsx-runtime",
          "react/jsx-dev-runtime": "https://esm.sh/stable/react@19.2.4/jsx-dev-runtime",
          "react-dom": "https://esm.sh/stable/react-dom@19.2.4",
          "react-dom/client": "https://esm.sh/stable/react-dom@19.2.4/client",
          "multiformats": "https://esm.sh/stable/multiformats@13.3.1",
          "multiformats/": "https://esm.sh/stable/multiformats@13.3.1/",
          "@ipld/dag-cbor": "https://esm.sh/stable/@ipld/dag-cbor@9.2.2?external=multiformats",
          "@ipld/dag-json": "https://esm.sh/stable/@ipld/dag-json@10.2.3?external=multiformats",
          "@clerk/clerk-react": "https://esm.sh/stable/@clerk/clerk-react@5.59.2?external=react,react-dom",
          "use-fireproof": "/bundles/fireproof-vibes-bridge.js",
          "@fireproof/clerk": "/bundles/fireproof-vibes-bridge.js",
          "framer-motion": "https://esm.sh/stable/framer-motion@11?external=react,react-dom"
        }
      }
    </script>
    <!-- Connect configuration - populated by assemble.js from .env -->
    <script>
      window.__VIBES_CONFIG__ = {
        tokenApiUri: "https://connect-share.exe.xyz/api/",
        cloudBackendUrl: "fpcloud://connect-share.exe.xyz?protocol=wss",
        // Must match VITE_CLERK_PUBLISHABLE_KEY in server/julian-bridge.service
        clerkPublishableKey: "pk_test_aW50ZXJuYWwtZGluZ28tMjguY2xlcmsuYWNjb3VudHMuZGV2JA"
      };
    </script>
    <!-- Load React globally for menu components -->
    <script type="module">
      import * as React from "react";
      window.React = React;
    </script>
    <!-- Load Framer Motion for UI animations -->
    <script type="module">
      import { motion, AnimatePresence, useReducedMotion } from "framer-motion";
      window.motion = motion;
      window.AnimatePresence = AnimatePresence;
      window.useReducedMotion = useReducedMotion;
    </script>
    <!-- Vibes component library (auto-generated, rarely changes) -->
    <script type="text/babel" src="/vibes.jsx"></script>
    <!-- Chat UI components (PixelFace, MessageBubble, SetupScreen, etc.) -->
    <script type="text/babel" src="/chat.jsx"></script>
    <!-- App component + initialization -->
    <script type="text/babel" data-type="module">
      import ReactDOMClient from "react-dom/client";
      import React, { useState, useEffect, useRef, useCallback, useMemo } from "react";
      import { useFireproofClerk } from "use-fireproof";

      // Pull chat.jsx window exports into module scope
      const { ArtifactViewer, JulianScreenEmbed, SetupScreen, ChatInput,
              MessageBubble, ToolCallBlock, ThinkingDots, StatusDots,
              PixelFace, ConfigError, LoadingError,
              AgentGrid, AgentFaceHeader, EggHatch,
              hashNameToFaceVariant, AGENT_COLORS,
              JobsPanel, ScreenGridPanel,
              motion: _motion, AnimatePresence: _AP } = window;
      const motion = _motion || { div: 'div' };
      const AnimatePresence = _AP || (({ children }) => children);

/* ── Artifact catalog ─────────────────────────────────────────────────────
 * Julian's memory catalog is a single XML document (catalog.xml) containing
 * all artifact metadata and stripped content. On first startSession, it's
 * fetched once and stored as a single Fireproof record — one write instead
 * of 28. The XML is static, generated at build time by scripts/build-catalog.js.
 *
 * To rebuild: bun scripts/build-catalog.js
 * ──────────────────────────────────────────────────────────────────────── */

// Parse catalog XML into metadata array for session start
function parseCatalogXML(xmlString) {
  const doc = new DOMParser().parseFromString(xmlString, "text/xml");
  return [...doc.querySelectorAll("artifact")].map(el => ({
    filename: el.getAttribute("filename"),
    dir: el.getAttribute("dir"),
    title: el.getAttribute("title"),
    category: el.getAttribute("category"),
    chapter: el.getAttribute("chapter"),
    description: el.getAttribute("description"),
  }));
}

// Ensure catalog record exists in Fireproof, fetch and store if missing
async function ensureCatalog(database) {
  try {
    const existing = await database.query("type", { key: "artifact-catalog" });
    if (existing.rows.length > 0) {
      const doc = existing.rows[0].doc || existing.rows[0].value;
      console.log("[catalog] Found existing catalog record");
      return parseCatalogXML(doc.content);
    }
  } catch (err) {
    console.warn("[catalog] Query failed, will fetch:", err);
  }

  try {
    const res = await fetch("/catalog.xml");
    if (!res.ok) throw new Error("HTTP " + res.status);
    const xml = await res.text();
    await database.put({ type: "artifact-catalog", content: xml, createdAt: new Date().toISOString() });
    console.log("[catalog] Fetched and stored catalog record");
    return parseCatalogXML(xml);
  } catch (err) {
    console.warn("[catalog] Failed to fetch catalog.xml:", err);
    return [];
  }
}

/* ── SSE stream reader ────────────────────────────────────────────────── */

async function streamSSEResponse(response, setLiveAssistant) {
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let sseBuffer = '';
  let finalBlocks = [];
  let notifiedArrival = false;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    sseBuffer += decoder.decode(value, { stream: true });
    const lines = sseBuffer.split('\n');
    sseBuffer = lines.pop() || '';

    for (const line of lines) {
      if (!line.startsWith('data: ')) continue;
      try {
        const data = JSON.parse(line.slice(6));
        if (data.type === 'done') continue;

        if (data.type === 'error') {
          window.SFX?.play('error');
          finalBlocks = [{ type: 'text', text: 'Error: ' + (data.data?.message || 'Unknown error') }];
          setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
          continue;
        }

        const eventData = data.data;
        if (!eventData) continue;
        if (eventData.type === 'system') continue;

        if (eventData.type === 'assistant' && eventData.message?.content) {
          const blocks = eventData.message.content.map(block => {
            if (block.type === 'text') return { type: 'text', text: block.text };
            if (block.type === 'tool_use') {
              return { type: 'tool_use', name: block.name, input: block.input };
            }
            return block;
          });
          finalBlocks = blocks;
          if (!notifiedArrival) { window.SFX?.play('notification'); notifiedArrival = true; }
          setLiveAssistant(prev => prev ? { ...prev, blocks, thinking: false, streaming: true } : null);
        }

        if (eventData.type === 'result') {
          if (eventData.result && finalBlocks.length === 0) {
            finalBlocks = [{ type: 'text', text: eventData.result }];
          }
          window.SFX?.play('success');
          setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
        }
      } catch (parseErr) {
        console.warn('[SSE] Failed to parse event:', parseErr, line);
      }
    }
  }

  return finalBlocks;
}

/* ── Main App ────────────────────────────────────────────────────────────── */

function App() {
  const { database, useLiveQuery } = useFireproofClerk("julian-chat-v6");

  useEffect(() => {
    window._julianDB = database;
  }, [database]);

  const { docs: persistedMessages } = useLiveQuery("type", { key: "message" });

  const [liveAssistant, setLiveAssistant] = useState(null);
  const [streaming, setStreaming] = useState(false);
  const [connected, setConnected] = useState(false);
  const [setupNeeded, setSetupNeeded] = useState(null);
  const [sessionActive, setSessionActive] = useState(false);
  const [wakingUp, setWakingUp] = useState(false);
  const [serverSessionId, setServerSessionId] = useState(null);
  const messagesEndRef = useRef(null);
  const [artifacts, setArtifacts] = useState([]);
  const [activeArtifact, setActiveArtifact] = useState('');
  const [menuDataLoaded, setMenuDataLoaded] = useState(false);
  const [filesData, setFilesData] = useState(null);
  const [skillsData, setSkillsData] = useState(null);

  // Agent Teams state
  const [activeAgent, setActiveAgent] = useState(null);
  const [summoning, setSummoning] = useState(false);
  const [menuTab, setMenuTab] = useState('files');
  const [sfxMuted, setSfxMuted] = useState(window.SFX?.isMuted ?? false);
  useEffect(() => {
    const handler = (e) => setSfxMuted(e.detail.muted);
    document.addEventListener('julian-sfx-mute-changed', handler);
    return () => document.removeEventListener('julian-sfx-mute-changed', handler);
  }, []);

  // Query agent identities from Fireproof
  const { docs: agentDocs } = useLiveQuery("type", { key: "agent-identity" });

  // Query jobs from Fireproof
  const { docs: jobDocs } = useLiveQuery("type", { key: "job" });
  const openJobs = useMemo(() =>
    (jobDocs || []).filter(j => j.status === 'open'),
    [jobDocs]
  );

  const agents = useMemo(() => {
    return (agentDocs || []).map(doc => ({
      name: doc.name,
      color: doc.color,
      colorName: doc.colorName,
      gender: doc.gender,
      faceVariant: doc.faceVariant,
      gridPosition: doc.gridPosition,
      // Agents are sleeping when no session is active (pessimistic model)
      sleeping: !sessionActive,
      hatching: doc.hatching || false,
      _id: doc._id,
    }));
  }, [agentDocs, sessionActive]);

  const activeAgentObj = useMemo(() => {
    if (!activeAgent) return null;
    return agents.find(a => a.name === activeAgent) || null;
  }, [activeAgent, agents]);

  const handleSelectAgent = useCallback((agentName) => {
    setActiveAgent(agentName);
    setLiveAssistant(null);
  }, []);

  // Unregister any leftover service worker (PWA removed during active dev)
  useEffect(() => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(regs =>
        regs.forEach(r => r.unregister())
      );
    }
  }, []);

  const getAuthHeaders = useCallback(async () => {
    // Wait for Clerk session to be ready (up to 5s)
    for (let i = 0; i < 10; i++) {
      if (window.Clerk?.session) break;
      await new Promise(r => setTimeout(r, 500));
    }
    try {
      const token = await window.Clerk?.session?.getToken();
      if (!token) {
        console.warn('[Auth] Clerk token unavailable. Clerk loaded:', !!window.Clerk, 'session:', !!window.Clerk?.session);
        return null;
      }
      return { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}`, 'X-Authorization': `Bearer ${token}` };
    } catch (err) {
      console.error('[Auth] Clerk getToken() error:', err);
      return null;
    }
  }, []);

  const refreshMenuData = useCallback(async () => {
    try {
      const headers = await getAuthHeaders();
      if (!headers) return;

      const [artifactsRes, skillsRes, agentsRes] = await Promise.allSettled([
        fetch('/api/artifacts', { headers }),
        fetch('/api/skills', { headers }),
        fetch('/api/agents', { headers }),
      ]);

      if (artifactsRes.status === 'fulfilled' && artifactsRes.value.ok) {
        const data = await artifactsRes.value.json();
        // Flatten tree into list for ArtifactViewer dropdown (HTML files with path-qualified names)
        function flattenTree(entries, prefix) {
          const result = [];
          for (const e of entries) {
            if (e.type === 'folder' && e.children) {
              result.push(...flattenTree(e.children, prefix ? prefix + '/' + e.name : e.name));
            } else if (e.type === 'file' && e.name.endsWith('.html')) {
              const fullName = prefix ? prefix + '/' + e.name : e.name;
              result.push({ name: fullName, modified: e.modified });
            }
          }
          return result;
        }
        const files = flattenTree(data.entries || [], '');
        setArtifacts(files);
        setFilesData(data);
        if (window.JScreen?.setMenuData) window.JScreen.setMenuData('files', data);
      }
      if (skillsRes.status === 'fulfilled' && skillsRes.value.ok) {
        const data = await skillsRes.value.json();
        setSkillsData(data);
        if (window.JScreen?.setMenuData) window.JScreen.setMenuData('skills', data);
      }
      if (agentsRes.status === 'fulfilled' && agentsRes.value.ok) {
        const data = await agentsRes.value.json();
        if (window.JScreen?.setMenuData) window.JScreen.setMenuData('agents', data);
      }
      setMenuDataLoaded(true);
    } catch (err) {
      console.warn('[Menu] refresh failed:', err);
    }
  }, [getAuthHeaders]);

  // Fetch menu data on mount
  useEffect(() => {
    refreshMenuData();
  }, [refreshMenuData]);

  // Auto-seed artifact catalog from catalog.xml on fresh Fireproof instances
  const catalogSeedRef = useRef(false);
  const catalogSeedAttempts = useRef(0);
  useEffect(() => {
    if (!database || catalogSeedRef.current) return;
    if (catalogSeedAttempts.current >= 5) return;
    catalogSeedRef.current = true;
    catalogSeedAttempts.current++;
    const attempt = catalogSeedAttempts.current;
    (async () => {
      try {
        await database.ready();
        await new Promise(r => setTimeout(r, 1000 * attempt));
        await ensureCatalog(database);
      } catch (err) {
        if (attempt < 5) console.debug('[CatalogSeed] Retry', attempt, '- stores not ready yet');
        else console.warn('[CatalogSeed] Failed after 5 attempts:', err);
        catalogSeedRef.current = false;
      }
    })();
  }, [database]);

  // When session becomes active, switch to screen tab to show Julian's avatar
  useEffect(() => {
    if (sessionActive) setMenuTab('screen');
  }, [sessionActive]);

  // Handle file selection from JulianScreen menu (filename may include path like "shared/foo.html")
  const handleFileSelect = useCallback((filename) => {
    // Ensure it's in the artifacts list
    setArtifacts(prev => {
      if (prev.some(f => f.name === filename)) return prev;
      return [...prev, { name: filename, modified: Date.now() }];
    });
    setActiveArtifact(filename);
    // HTML files can be rendered — switch to browser tab automatically
    if (filename.endsWith('.html')) {
      setMenuTab('browser');
    }
  }, []);

  useEffect(() => {
    let cancelled = false;
    const tryInit = async () => {
      const headers = await getAuthHeaders();
      if (!headers) {
        if (!cancelled) setTimeout(tryInit, 500);
        return;
      }
      try {
        const r = await fetch('/api/health', { headers });
        if (!r.ok) {
          // Auth failed or server error — show setup screen so user can re-auth
          if (!cancelled) { setConnected(false); setSetupNeeded(true); }
          return;
        }
        const data = await r.json();
        if (!cancelled) {
          setSessionActive(data.sessionActive ?? false);
          setConnected(data.sessionActive ?? false);
          setSetupNeeded(data.needsSetup ?? false);
          if (data.sessionId) setServerSessionId(data.sessionId);
          if (data.version) window.__julianVersion = data.version;
        }
      } catch {
        if (!cancelled) {
          setConnected(false);
          setSetupNeeded(true);
        }
      }
    };
    tryInit();
    return () => { cancelled = true; };
  }, [getAuthHeaders]);


  // Poll health every 10s to detect session end/crash
  useEffect(() => {
    if (!sessionActive) return;
    const id = setInterval(async () => {
      try {
        const headers = await getAuthHeaders();
        if (!headers) return;
        const r = await fetch('/api/health', { headers });
        if (!r.ok) return;
        const data = await r.json();
        if (!data.sessionActive) {
          setSessionActive(false);
          setConnected(false);
          setStreaming(false);
          setServerSessionId(null);
          setMenuTab('files');
        } else if (data.sessionId && !serverSessionId) {
          // Multi-device: pick up sessionId from running process
          setServerSessionId(data.sessionId);
        }
      } catch {}
    }, 10000);
    return () => clearInterval(id);
  }, [sessionActive, serverSessionId, getAuthHeaders]);

  // Auto-reload on deploy: poll version every 15s regardless of session state
  useEffect(() => {
    const id = setInterval(async () => {
      try {
        const r = await fetch('/api/health');
        if (!r.ok) return;
        const data = await r.json();
        if (data.version && window.__julianVersion && data.version !== window.__julianVersion) {
          console.log(`[Deploy] Version changed: ${window.__julianVersion} → ${data.version}, reloading`);
          location.reload();
        }
      } catch {}
    }, 15000);
    return () => clearInterval(id);
  }, []);

  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [persistedMessages, liveAssistant]);

  const displayMessages = React.useMemo(() => {
    const sorted = [...(persistedMessages || [])].sort((a, b) => {
      if (a._id < b._id) return -1;
      if (a._id > b._id) return 1;
      return 0;
    });
    // Filter by active agent — each agent has their own conversation thread
    const filtered = sorted.filter(doc => {
      if (activeAgent) return doc.agentName === activeAgent;
      return !doc.agentName; // Julian's messages have no agentName
    });
    const msgs = filtered.map(doc => ({
      id: doc._id,
      role: doc.role,
      text: doc.text || '',
      blocks: doc.blocks || [],
      thinking: false,
      streaming: false,
    }));
    if (liveAssistant) {
      msgs.push(liveAssistant);
    }
    return msgs;
  }, [persistedMessages, liveAssistant, activeAgent]);

  const isMobile = useMobile();

  const handleSummon = useCallback(async () => {
    if (summoning) return;
    setSummoning(true);
    window.SFX?.play('open');
    try {
      const headers = await getAuthHeaders();
      if (!headers) return;

      // Start a session if none is active
      if (!sessionActive) {
        const startRes = await fetch('/api/session/start', {
          method: 'POST',
          headers,
          body: JSON.stringify({ previousTranscript: [], artifactCatalog: await ensureCatalog(database) }),
        });
        if (!startRes.ok) {
          console.error('[Summon] Failed to start session');
          return;
        }
        const newSid = startRes.headers.get('X-Session-Id');
        if (newSid) setServerSessionId(newSid);
        setSessionActive(true);
        setConnected(true);
        await new Promise(r => setTimeout(r, 1000));
      }

      // Create hatching placeholders so eggs appear immediately
      const palette = [
        { pos: 0, color: '#c9b1e8', colorName: 'Violet Heaven', gender: 'woman' },
        { pos: 1, color: '#755d00', colorName: 'Ayahuasca Vine', gender: 'man' },
        { pos: 2, color: '#00afd1', colorName: 'Aquarius', gender: 'woman' },
        { pos: 3, color: '#007e98', colorName: 'Pacific Pleasure', gender: 'man' },
        { pos: 5, color: '#c85cb4', colorName: 'Barbiecore', gender: 'woman' },
        { pos: 6, color: '#da89c9', colorName: 'Pink Punk', gender: 'man' },
        { pos: 7, color: '#B8DDE6', colorName: 'Salt Air', gender: 'woman' },
        { pos: 8, color: '#F2C4B0', colorName: 'Cloud Coral', gender: 'man' },
      ];
      const hatchingDocs = {};
      for (const p of palette) {
        const doc = await database.put({
          type: 'agent-identity', hatching: true,
          gridPosition: p.pos, color: p.color,
          colorName: p.colorName, gender: p.gender,
        });
        hatchingDocs[p.pos] = doc.id;
        console.log('[Summon] Created hatching egg at position', p.pos);
      }

      // Send summon through the chat — Julian's response streams back via SSE
      const response = await fetch('/api/agents/summon', {
        method: 'POST',
        headers,
      });

      // Read the SSE stream and detect [AGENT_REGISTERED] markers
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let sseBuffer = '';

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        sseBuffer += decoder.decode(value, { stream: true });
        const lines = sseBuffer.split('\n');
        sseBuffer = lines.pop() || '';

        for (const line of lines) {
          if (!line.startsWith('data: ')) continue;
          try {
            const data = JSON.parse(line.slice(6));
            if (data.type === 'done') continue;
            const eventData = data.data;
            if (!eventData?.message?.content) continue;

            for (const block of eventData.message.content) {
              if (block.type !== 'text') continue;
              // Detect [AGENT_REGISTERED] markers in Julian's response
              const agentLines = block.text.split('\n').filter(l => l.includes('[AGENT_REGISTERED]'));
              for (const agentLine of agentLines) {
                try {
                  const jsonStr = agentLine.slice(agentLine.indexOf('{'));
                  const agent = JSON.parse(jsonStr);
                  if (agent.name && agent.gridPosition != null) {
                    const hatchId = hatchingDocs[agent.gridPosition];
                    if (hatchId) {
                      // Update the hatching placeholder with full identity
                      try {
                        const existing = await database.get(hatchId);
                        await database.put({ ...existing, ...agent, type: 'agent-identity', hatching: false });
                        window.SFX?.play('select');
                        console.log('[Summon] Hatched agent:', agent.name, 'at position', agent.gridPosition);
                      } catch (e) {
                        // Fallback: create new doc if hatching doc was lost
                        await database.put({ ...agent, type: 'agent-identity' });
                        window.SFX?.play('select');
                        console.log('[Summon] Saved agent (fallback):', agent.name, 'at position', agent.gridPosition);
                      }
                    } else {
                      // No hatching doc for this position, create fresh
                      const existingPositions = (agentDocs || []).map(d => d.gridPosition);
                      if (!existingPositions.includes(agent.gridPosition)) {
                        await database.put({ ...agent, type: 'agent-identity' });
                        window.SFX?.play('select');
                        console.log('[Summon] Saved agent:', agent.name, 'at position', agent.gridPosition);
                      }
                    }
                  }
                } catch (parseErr) {
                  console.debug('[Summon] Failed to parse agent identity:', parseErr);
                }
              }
            }
          } catch (e) {}
        }
      }
    } catch (err) {
      console.error('[Summon] Error:', err);
    } finally {
      setSummoning(false);
    }
  }, [summoning, sessionActive, getAuthHeaders, database, agentDocs]);

  // Wake sleeping agents — query their transcripts from Fireproof, assemble payloads, send to Julian
  const handleWake = useCallback(async () => {
    if (summoning) return;
    setSummoning(true);
    window.SFX?.play('navigate');
    try {
      const headers = await getAuthHeaders();
      if (!headers) return;

      // Start a session if none is active
      if (!sessionActive) {
        // Trigger startSession first — reuse the same flow as clicking the chat
        // We need a session for Julian to receive the wake message
        const startRes = await fetch('/api/session/start', {
          method: 'POST',
          headers,
          body: JSON.stringify({ previousTranscript: [], artifactCatalog: await ensureCatalog(database) }),
        });
        if (!startRes.ok) {
          console.error('[Wake] Failed to start session');
          return;
        }
        const newSid = startRes.headers.get('X-Session-Id');
        if (newSid) setServerSessionId(newSid);
        setSessionActive(true);
        setConnected(true);
        // Wait for session to settle
        await new Promise(r => setTimeout(r, 1000));
      }

      // Query all messages from Fireproof
      const allMessages = await database.query("type", { key: "message" });
      const allDocs = (allMessages.rows || []).map(r => r.doc || r.value || r);

      // Build per-agent payloads
      const agentPayloads = (agentDocs || []).map(agent => {
        // Find this agent's most recent session transcript
        const agentMsgs = allDocs.filter(d => d.agentName === agent.name);
        // Group by session and pick the most recent
        const bySession = {};
        for (const m of agentMsgs) {
          const sid = m.serverSessionId;
          if (!sid) continue;
          if (!bySession[sid]) bySession[sid] = [];
          bySession[sid].push(m);
        }
        const sessionIds = Object.keys(bySession).sort((a, b) => {
          const lastA = bySession[a].at(-1)?.createdAt || "";
          const lastB = bySession[b].at(-1)?.createdAt || "";
          return lastB.localeCompare(lastA);
        });
        const recentSession = sessionIds[0];
        let transcript = '';
        if (recentSession && bySession[recentSession]) {
          transcript = bySession[recentSession]
            .sort((a, b) => (a._id < b._id ? -1 : 1))
            .map(m => {
              if (m.role === 'user') return `[${m.speakerName || 'Marcus'}]: ${m.text || ''}`;
              const text = (m.blocks || []).filter(b => b.type === 'text').map(b => b.text).join('\n');
              return `[${m.speakerName || agent.name}]: ${text}`;
            })
            .filter(line => line.includes(': ') && line.split(': ').slice(1).join(': ').trim())
            .join('\n');
        }

        return {
          name: agent.name,
          color: agent.color,
          colorName: agent.colorName || '',
          position: agent.gridPosition,
          soul: agent.individuationArtifact || '',
          transcript,
        };
      });

      // Assemble the wake message
      const payloadXml = agentPayloads.map(a =>
        `  <agent name="${a.name}" color="${a.color}" colorName="${a.colorName}" position="${a.position}">\n` +
        `    <soul>${a.soul}</soul>\n` +
        `    <transcript>${a.transcript}</transcript>\n` +
        `  </agent>`
      ).join('\n');

      const wakeMessage = `[WAKE AGENTS]\n<agent-payloads>\n${payloadXml}\n</agent-payloads>`;

      // Send through the chat endpoint
      await fetch('/api/chat', {
        method: 'POST',
        headers,
        body: JSON.stringify({ message: wakeMessage }),
      });

      console.log('[Wake] Sent wake message for', agentPayloads.length, 'agents');
    } catch (err) {
      console.error('[Wake] Error:', err);
    } finally {
      setSummoning(false);
    }
  }, [summoning, sessionActive, getAuthHeaders, database, agentDocs]);

  const sendMessage = useCallback(async (text) => {
    if (streaming) return;
    if (!sessionActive) return;

    // Show thinking bubble immediately
    window.SFX?.play('click');
    const liveMsg = { id: 'live-' + Date.now(), role: 'assistant', blocks: [], thinking: true, streaming: true };
    setLiveAssistant(liveMsg);
    setStreaming(true);

    // Persist user message (fire-and-forget — useLiveQuery picks it up)
    const speakerName = window.Clerk?.user?.firstName || "Marcus";
    database.put({
      type: "message",
      category: "transcript",
      role: "user",
      speakerType: "human",
      speakerName,
      agentName: activeAgent || undefined,
      text,
      blocks: [],
      createdAt: new Date().toISOString(),
      serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    let finalBlocks = [];

    try {
      const headers = await getAuthHeaders();
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers,
        body: JSON.stringify({ message: text, targetAgent: activeAgent || undefined }),
      });

      finalBlocks = await streamSSEResponse(response, setLiveAssistant);
    } catch (err) {
      console.error('[chat] fetch error:', err);
      window.SFX?.play('error');
      finalBlocks = [{ type: 'text', text: 'Connection error: ' + err.message }];
      setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
    }

    // Persist assistant response (fire-and-forget)
    database.put({
      type: "message",
      category: "transcript",
      role: "assistant",
      speakerType: "agent",
      speakerName: activeAgent || "Julian",
      agentName: activeAgent || undefined,
      text: '',
      blocks: finalBlocks,
      createdAt: new Date().toISOString(),
      serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    // ── Auto-catalog: detect Write tool for memory/*.html and extract meta tags ──
    const writeBlocks = finalBlocks.filter(b =>
      b.type === 'tool_use' && b.name === 'Write' &&
      b.input?.file_path?.includes('memory/') &&
      b.input?.file_path?.endsWith('.html')
    );
    for (const wb of writeBlocks) {
      const filename = wb.input.file_path.split('/').pop();
      setTimeout(async () => {
        try {
          const resp = await fetch('/api/artifacts/' + encodeURIComponent(filename));
          if (!resp.ok) return;
          const html = await resp.text();
          const dpParser = new DOMParser();
          const parsed = dpParser.parseFromString(html, 'text/html');
          const description = parsed.querySelector('meta[name="artifact-description"]')?.content;
          const artCategory = parsed.querySelector('meta[name="artifact-category"]')?.content || 'knowledge';
          const chapter = parsed.querySelector('meta[name="artifact-chapter"]')?.content || '';
          if (description) {
            const existing = await database.query("type", { key: "artifact" });
            const entry = (existing.rows || []).find(r => (r.doc || r.value).filename === filename);
            if (entry) {
              const existingDoc = entry.doc || entry.value;
              await database.put({ ...existingDoc, description, category: artCategory, chapter });
            } else {
              await database.put({ type: "artifact", category: artCategory, filename, description, chapter, createdAt: new Date().toISOString() });
            }
          }
        } catch (e) {
          console.warn('[catalog] Failed to auto-catalog:', filename, e);
        }
      }, 2500);
    }

    setLiveAssistant(null);
    setStreaming(false);
    setConnected(true);
    // Refresh menu data in case Julian created new artifacts
    refreshMenuData();
  }, [streaming, sessionActive, serverSessionId, database, getAuthHeaders, refreshMenuData, activeAgent]);

  const handleOfferWork = useCallback(async () => {
    if (streaming || !sessionActive) return;
    const jobSummaries = openJobs
      .map(j => `- ${j.name}: ${j.description}`)
      .join('\n');
    const routingMsg = `[OFFER WORK TO AGENT: ${activeAgent}] Available jobs:\n${jobSummaries}`;
    const displayMsg = `Would you like to hear about available work?`;

    // Show thinking bubble
    const liveMsg = { id: 'live-' + Date.now(), role: 'assistant', blocks: [], thinking: true, streaming: true };
    setLiveAssistant(liveMsg);
    setStreaming(true);

    // Persist clean display message
    const speakerName = window.Clerk?.user?.firstName || "Marcus";
    database.put({
      type: "message", category: "transcript", role: "user",
      speakerType: "human", speakerName,
      agentName: activeAgent || undefined,
      text: displayMsg, blocks: [],
      createdAt: new Date().toISOString(), serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    let finalBlocks = [];
    try {
      const headers = await getAuthHeaders();
      const response = await fetch('/api/chat', {
        method: 'POST', headers,
        body: JSON.stringify({ message: routingMsg, targetAgent: activeAgent || undefined }),
      });
      finalBlocks = await streamSSEResponse(response, setLiveAssistant);
    } catch (err) {
      finalBlocks = [{ type: 'text', text: 'Connection error: ' + err.message }];
      setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
    }

    database.put({
      type: "message", category: "transcript", role: "assistant",
      speakerType: "agent", speakerName: activeAgent || "Julian",
      agentName: activeAgent || undefined,
      text: '', blocks: finalBlocks,
      createdAt: new Date().toISOString(), serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    setLiveAssistant(null);
    setStreaming(false);
    setConnected(true);
  }, [activeAgent, openJobs, streaming, sessionActive, serverSessionId, database, getAuthHeaders]);

  const startSession = useCallback(async () => {
    if (wakingUp || sessionActive) return;
    setWakingUp(true);
    window.SFX?.play('level-up');

    // Create a live assistant message for the wake-up response
    const liveMsg = { id: 'wakeup-' + Date.now(), role: 'assistant', blocks: [], thinking: true, streaming: true };
    setLiveAssistant(liveMsg);

    let finalBlocks = [];
    let newSessionId = null;

    try {
      const headers = await getAuthHeaders();
      if (!headers) {
        finalBlocks = [{ type: 'text', text: 'Not signed in. Please sign in with Clerk first.' }];
        setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
        setWakingUp(false);
        return;
      }

      // ── Rehydration: query Fireproof for previous session transcript ──
      let previousTranscript = [];
      try {
        const allMessages = await database.query("type", { key: "message" });
        // Group messages by serverSessionId
        const bySession = {};
        for (const doc of (allMessages.rows || [])) {
          const d = doc.doc || doc.value || doc;
          const sid = d.serverSessionId;
          if (!sid) continue; // skip legacy messages without serverSessionId
          if (!bySession[sid]) bySession[sid] = [];
          bySession[sid].push(d);
        }
        // Find the most recent completed session (not the current one)
        const sessionIds = Object.keys(bySession)
          .filter(id => id && id !== serverSessionId)
          .sort((a, b) => {
            const lastA = bySession[a].at(-1)?.createdAt || "";
            const lastB = bySession[b].at(-1)?.createdAt || "";
            return lastB.localeCompare(lastA);
          });
        const previousSessionId = sessionIds[0];
        if (previousSessionId && bySession[previousSessionId]) {
          previousTranscript = bySession[previousSessionId]
            .sort((a, b) => (a._id < b._id ? -1 : 1))
            .map(msg => {
              if (msg.role === "user") {
                return {
                  role: "user",
                  speakerType: msg.speakerType || "human",
                  speakerName: msg.speakerName || "Marcus",
                  text: msg.text || "",
                };
              }
              const textBlocks = (msg.blocks || [])
                .filter(b => b.type === "text")
                .map(b => b.text);
              return {
                role: "assistant",
                speakerType: msg.speakerType || "agent",
                speakerName: msg.speakerName || "Julian",
                text: textBlocks.join("\n"),
              };
            })
            .filter(msg => msg.text.trim());
        }
      } catch (err) {
        console.warn('[rehydration] Failed to query previous transcript:', err);
      }

      // ── Catalog: one Fireproof record, one fetch if missing ──
      const artifactCatalog = await ensureCatalog(database);

      const demoMode = new URLSearchParams(window.location.search).get('demo') === '1';
      const response = await fetch('/api/session/start', {
        method: 'POST',
        headers,
        body: JSON.stringify({ previousTranscript, artifactCatalog, demoMode }),
      });

      if (!response.ok) {
        let errMsg = `HTTP ${response.status}`;
        try { errMsg = (await response.json()).error || errMsg; } catch {}
        finalBlocks = [{ type: 'text', text: 'Failed to start session: ' + errMsg }];
        setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
        setWakingUp(false);
        return;
      }

      // Capture serverSessionId from response header
      newSessionId = response.headers.get('X-Session-Id');
      if (newSessionId) setServerSessionId(newSessionId);

      // Stream the wake-up SSE response
      finalBlocks = await streamSSEResponse(response, setLiveAssistant);
    } catch (err) {
      finalBlocks = [{ type: 'text', text: 'Connection error: ' + err.message }];
      setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
    }

    // Persist the wake-up message (fire-and-forget)
    if (finalBlocks.length > 0) {
      database.put({
        type: "message",
        category: "transcript",
        role: "assistant",
        speakerType: "agent",
        speakerName: "Julian",
        text: '',
        blocks: finalBlocks,
        createdAt: new Date().toISOString(),
        serverSessionId: newSessionId || serverSessionId,
      }).catch(err => console.error('[chat] Fireproof wake-up put failed:', err));
    }

    setLiveAssistant(null);
    setSessionActive(true);
    setConnected(true);
    setWakingUp(false);
    setMenuTab('screen');
  }, [wakingUp, sessionActive, serverSessionId, database, getAuthHeaders]);

  const endSession = useCallback(async () => {
    window.SFX?.play('shutdown');
    try {
      const headers = await getAuthHeaders();
      await fetch('/api/session/end', { method: 'POST', headers });
    } catch {}
    setSessionActive(false);
    setConnected(false);
    setServerSessionId(null);
    setMenuTab('files');
    refreshMenuData();
  }, [getAuthHeaders, refreshMenuData]);

  const startNewConversation = useCallback(async () => {
    if (!confirm("Start new conversation? Julian will remember what you talked about.")) return;
    // Kill the existing subprocess, then reload — fresh page will show "Start Session"
    // which triggers rehydration from Fireproof on next start
    try {
      const headers = await getAuthHeaders();
      if (headers) await fetch('/api/session/end', { method: 'POST', headers });
    } catch {}
    // Brief delay for process cleanup, then reload
    await new Promise(r => setTimeout(r, 500));
    window.location.reload();
  }, [getAuthHeaders]);

  return (
    <>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        * { box-sizing: border-box; }
        body {
          margin: 0; padding: 0;
          font-family: 'VT323', monospace;
          background-color: #FFD600;
          color: #000;
          -webkit-font-smoothing: antialiased;
        }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0F0F0F; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #FFD600; }
        @keyframes blink {
          0%, 100% { opacity: 1; }
          50% { opacity: 0; }
        }
        @keyframes pulse-dot {
          0%, 80%, 100% { opacity: 0.6; }
          40% { opacity: 1; }
        }
        @keyframes pulse {
          0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
          40% { opacity: 1; transform: scale(1.2); }
        }
        #send-btn:active {
          transform: translateY(4px);
          box-shadow: 0 0 0 #999, inset 0 2px 5px rgba(0,0,0,0.1) !important;
        }
        input::placeholder {
          color: rgba(0,0,0,0.4);
        }
        body::before {
          content: '\u00D7';
          position: fixed;
          top: 4px;
          left: 8px;
          font-size: 28px;
          color: rgba(0,0,0,0.2);
          font-weight: 900;
          z-index: 50;
          pointer-events: none;
        }
        body::after {
          content: '\u00D7';
          position: fixed;
          top: 4px;
          right: 8px;
          font-size: 28px;
          color: rgba(0,0,0,0.2);
          font-weight: 900;
          z-index: 50;
          pointer-events: none;
        }
        #container {
          background-color: #FFD600 !important;
        }
      `}</style>

      {setupNeeded === null ? (
        /* ── Loading ── */
        <div style={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column',
          gap: 16,
          backgroundColor: '#FFD600',
        }}>
          <PixelFace talking={false} size={100} />
          <div style={{
            fontFamily: "'VT323', monospace",
            fontSize: '1.4rem',
            color: '#000',
            opacity: 0.5,
            animation: 'blink 1.5s step-end infinite',
          }}>
            BOOTING...
          </div>
        </div>
      ) : setupNeeded ? (
        /* ── Setup Screen ── */
        <SetupScreen
          getAuthHeaders={getAuthHeaders}
          onComplete={() => { setSetupNeeded(false); setConnected(true); }}
        />
      ) : isMobile ? (
        /* ── Mobile: Three-section vertical stack ── */
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          height: '100vh',
          backgroundColor: '#FFD600',
          overflow: 'hidden',
        }}>
          {/* Mobile header: PixelFace full-width */}
          <div style={{
            background: '#0F0F0F',
            padding: '8px 12px',
            display: 'flex',
            alignItems: 'center',
            gap: 12,
            borderBottom: '2px solid #2a2a2a',
            flexShrink: 0,
          }}>
            <PixelFace talking={streaming} size={48} />
            <div style={{ flex: 1 }}>
              <div style={{
                fontFamily: "'VT323', monospace",
                fontSize: '1.2rem',
                color: '#FFD600',
                letterSpacing: '0.05em',
              }}>JULIAN</div>
              <div style={{
                fontFamily: "'VT323', monospace",
                fontSize: '0.75rem',
                color: '#AA8800',
                opacity: 0.6,
              }}>
                {!sessionActive ? 'OFFLINE' : streaming ? 'PROCESSING...' : wakingUp ? 'WAKING UP...' : 'LISTENING'}
              </div>
            </div>
            <StatusDots ok={sessionActive} />
            <button
              onClick={startNewConversation}
              style={{
                fontFamily: "'VT323', monospace",
                fontSize: '0.75rem',
                color: '#AA8800',
                background: '#1a1a00',
                border: '1px solid #333',
                borderRadius: 4,
                padding: '3px 8px',
                cursor: 'pointer',
              }}
            >NEW</button>
            {sessionActive && (
              <button
                onClick={endSession}
                style={{
                  fontFamily: "'VT323', monospace",
                  fontSize: '0.75rem',
                  color: '#ff4444',
                  background: '#1a0000',
                  border: '1px solid #333',
                  borderRadius: 4,
                  padding: '3px 8px',
                  cursor: 'pointer',
                }}
              >END</button>
            )}
          </div>

          {/* Mobile screen: JulianScreen in 4:3 */}
          <div style={{
            padding: 8,
            flexShrink: 0,
          }}>
            <JulianScreenEmbed sessionActive={sessionActive} compact onFileSelect={handleFileSelect} />
          </div>

          {/* Mobile artifact viewer: shown only when an artifact is selected */}
          {activeArtifact && (
            <div style={{
              padding: '0 8px',
              flex: 1,
              minHeight: 0,
              display: 'flex',
              flexDirection: 'column',
            }}>
              <ArtifactViewer
                activeArtifact={activeArtifact}
                artifacts={artifacts}
                onSelect={setActiveArtifact}
              />
              <button
                onClick={() => setActiveArtifact('')}
                style={{
                  fontFamily: "'VT323', monospace",
                  fontSize: '0.85rem',
                  color: '#AA8800',
                  background: '#1a1a00',
                  border: '1px solid #333',
                  borderRadius: 4,
                  padding: '6px 12px',
                  cursor: 'pointer',
                  textTransform: 'uppercase',
                  marginTop: 4,
                  alignSelf: 'center',
                }}
              >CLOSE VIEWER</button>
            </div>
          )}

          {/* Mobile chat: messages + input (hidden when artifact viewer is open) */}
          <div style={{
            flex: 1,
            display: activeArtifact ? 'none' : 'flex',
            flexDirection: 'column',
            minHeight: 0,
            padding: '0 8px 8px',
          }}>
            <div style={{
              flex: 1,
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderRadius: '12px 12px 0 0',
              overflowY: 'auto',
              padding: 12,
              position: 'relative',
            }}>
              <div style={{
                position: 'absolute', inset: 0,
                background: 'linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06))',
                backgroundSize: '100% 2px, 3px 100%',
                opacity: 0.1, pointerEvents: 'none', zIndex: 5,
              }} />
              <div style={{ position: 'relative', zIndex: 1 }}>
                {displayMessages.map(msg => (
                  <MessageBubble key={msg.id} message={msg} />
                ))}
                <div ref={messagesEndRef} />
              </div>
            </div>
            <div style={{
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderTop: '1px dashed #333',
              borderRadius: '0 0 12px 12px',
              padding: '0 12px',
              flexShrink: 0,
            }}>
              {!sessionActive && !wakingUp ? (
                <div style={{ padding: '10px 0', textAlign: 'center' }}>
                  <button onClick={startSession} style={{
                    padding: '8px 20px',
                    fontFamily: "'VT323', monospace",
                    fontSize: '1rem',
                    textTransform: 'uppercase',
                    background: '#FFD600', color: '#000',
                    border: '2px solid #000', borderRadius: 4,
                    cursor: 'pointer', boxShadow: '3px 3px 0 #000',
                  }}>START SESSION</button>
                </div>
              ) : (
                <>
                  {activeAgent && openJobs.length > 0 && (
                    <button
                      onClick={handleOfferWork}
                      disabled={streaming}
                      style={{
                        width: '100%',
                        padding: '6px 0',
                        marginTop: 6,
                        fontFamily: "'VT323', monospace",
                        fontSize: '0.9rem',
                        color: streaming ? '#666' : '#FF88FF',
                        background: streaming ? '#1a1a1a' : '#1a001a',
                        border: `1px solid ${streaming ? '#333' : '#FF88FF'}`,
                        borderRadius: 4,
                        cursor: streaming ? 'default' : 'pointer',
                        letterSpacing: '0.1em',
                        textTransform: 'uppercase',
                      }}
                    >
                      OFFER WORK
                    </button>
                  )}
                  <ChatInput onSend={sendMessage} disabled={streaming || !sessionActive || wakingUp} />
                </>
              )}
            </div>
          </div>
        </div>
      ) : (
        /* ── Desktop: Chat sidebar + JulianScreen ── */
        <div style={{
          display: 'flex',
          height: '100vh',
          padding: 16,
          gap: 16,
          backgroundColor: '#FFD600',
        }}>
          {/* Left column: Chat sidebar */}
          <div style={{
            width: 420,
            minWidth: 320,
            flexShrink: 0,
            display: 'flex',
            flexDirection: 'column',
            height: '100%',
          }}>
            {/* Face header */}
            <div style={{
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderBottom: '1px dashed #333',
              borderRadius: '12px 12px 0 0',
              padding: '12px 16px',
              boxShadow: 'inset 0 2px 10px rgba(0,0,0,0.5)',
              display: 'flex',
              alignItems: 'center',
              gap: 12,
              position: 'relative',
            }}>
              <div style={{ position: 'absolute', top: 8, left: 12 }}>
                <span style={{
                  fontFamily: "'VT323', monospace",
                  fontSize: '0.75rem',
                  color: '#AA8800',
                  letterSpacing: '0.2em',
                }}>SYS.VER.2.4</span>
              </div>
              <div style={{ position: 'absolute', top: 10, right: 12 }}>
                <StatusDots ok={sessionActive} />
              </div>

              {activeAgentObj ? (
                <AgentFaceHeader
                  agent={activeAgentObj}
                  talking={streaming}
                  onBack={() => handleSelectAgent(null)}
                />
              ) : (
                <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginTop: 16, width: '100%' }}>
                  <PixelFace talking={streaming} size={56} />
                  <div style={{ flex: 1 }}>
                    <div style={{
                      fontFamily: "'VT323', monospace",
                      fontSize: '1.4rem',
                      color: '#FFD600',
                      letterSpacing: '0.05em',
                    }}>JULIAN</div>
                    <div style={{
                      fontFamily: "'VT323', monospace",
                      fontSize: '0.85rem',
                      color: '#AA8800',
                      opacity: 0.6,
                    }}>
                      {!sessionActive ? 'OFFLINE' : streaming ? 'PROCESSING...' : wakingUp ? 'WAKING UP...' : 'LISTENING'}
                    </div>
                  </div>
                  <button
                    onClick={startNewConversation}
                    style={{
                      fontFamily: "'VT323', monospace",
                      fontSize: '0.85rem',
                      color: '#AA8800',
                      background: '#1a1a00',
                      border: '1px solid #333',
                      borderRadius: 4,
                      padding: '4px 10px',
                      cursor: 'pointer',
                      textTransform: 'uppercase',
                    }}
                  >NEW</button>
                  {sessionActive && (
                    <button
                      onClick={endSession}
                      style={{
                        fontFamily: "'VT323', monospace",
                        fontSize: '0.85rem',
                        color: '#ff4444',
                        background: '#1a0000',
                        border: '1px solid #333',
                        borderRadius: 4,
                        padding: '4px 10px',
                        cursor: 'pointer',
                        textTransform: 'uppercase',
                      }}
                    >END</button>
                  )}
                </div>
              )}
            </div>

            {/* Chat messages area */}
            <div style={{
              flex: 1,
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderTop: 'none',
              borderBottom: 'none',
              overflowY: 'auto',
              padding: 16,
              position: 'relative',
            }}>
              {/* CRT scanlines */}
              <div style={{
                position: 'absolute',
                inset: 0,
                background: 'linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06))',
                backgroundSize: '100% 2px, 3px 100%',
                opacity: 0.1,
                pointerEvents: 'none',
                zIndex: 5,
              }} />
              <div style={{ position: 'relative', zIndex: 1 }}>
                {displayMessages.map(msg => (
                  <MessageBubble key={msg.id} message={msg} />
                ))}
                <div ref={messagesEndRef} />
              </div>
            </div>

            {/* Input footer */}
            <div style={{
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderTop: '1px dashed #333',
              borderRadius: '0 0 12px 12px',
              padding: '0 16px',
              boxShadow: 'inset 0 -2px 10px rgba(0,0,0,0.5)',
            }}>
              {!sessionActive && !wakingUp ? (
                <div style={{ padding: '12px 0', textAlign: 'center' }}>
                  <button
                    onClick={startSession}
                    style={{
                      padding: '10px 24px',
                      fontFamily: "'VT323', monospace",
                      fontSize: '1.1rem',
                      textTransform: 'uppercase',
                      letterSpacing: '0.1em',
                      background: '#FFD600',
                      color: '#000',
                      border: '2px solid #000',
                      borderRadius: 4,
                      cursor: 'pointer',
                      boxShadow: '3px 3px 0 #000',
                    }}
                  >START SESSION</button>
                </div>
              ) : (
                <>
                  {activeAgent && openJobs.length > 0 && (
                    <button
                      onClick={handleOfferWork}
                      disabled={streaming}
                      style={{
                        width: '100%',
                        padding: '8px 0',
                        marginTop: 8,
                        fontFamily: "'VT323', monospace",
                        fontSize: '1rem',
                        color: streaming ? '#666' : '#FF88FF',
                        background: streaming ? '#1a1a1a' : '#1a001a',
                        border: `1px solid ${streaming ? '#333' : '#FF88FF'}`,
                        borderRadius: 4,
                        cursor: streaming ? 'default' : 'pointer',
                        letterSpacing: '0.1em',
                        textTransform: 'uppercase',
                      }}
                    >
                      OFFER WORK
                    </button>
                  )}
                  <ChatInput onSend={sendMessage} disabled={streaming || !sessionActive || wakingUp} />
                </>
              )}
            </div>
          </div>

          {/* Right column: unified tab bar + content */}
          <div style={{
            flex: 1,
            minWidth: 0,
            display: 'flex',
            flexDirection: 'column',
            height: '100%',
            border: '1px solid #333',
            borderRadius: 12,
            background: '#0c0c0c',
            overflow: 'hidden',
          }}>
            {/* Universal tab bar — glass panel with pill buttons */}
            <div style={{
              display: 'flex',
              alignItems: 'center',
              padding: '0 12px',
              gap: 6,
              height: 48,
              flexShrink: 0,
              background: 'rgba(255,255,255,0.03)',
              backdropFilter: 'blur(10px)',
              borderBottom: '1px solid rgba(255,255,255,0.05)',
            }}>
              {['SCREEN', 'BROWSER', 'FILES', 'SKILLS', 'AGENTS', 'JOBS'].map(tab => {
                const tabKey = tab.toLowerCase();
                const isActive = tabKey === menuTab;
                return (
                  <button
                    key={tab}
                    onClick={() => {
                      if (isActive) return;
                      window.SFX?.play('tab');
                      setMenuTab(tabKey);
                      // Always exit canvas menu when switching tabs
                      if (window.JScreen?.exitMenu) window.JScreen.exitMenu();
                    }}
                    style={{
                      height: 32,
                      padding: '0 14px',
                      borderRadius: 9999,
                      border: isActive ? '1px solid #00afd1' : '1px solid rgba(255,255,255,0.1)',
                      background: isActive ? '#00afd1' : 'transparent',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      fontSize: 10,
                      fontFamily: "'Inter', sans-serif",
                      fontWeight: isActive ? 700 : 500,
                      textTransform: 'uppercase',
                      letterSpacing: '0.15em',
                      color: isActive ? '#000' : 'rgba(255,255,255,0.5)',
                      cursor: isActive ? 'default' : 'pointer',
                      transition: 'background 300ms ease, color 300ms ease, border-color 300ms ease, box-shadow 300ms ease',
                      boxShadow: isActive ? '0 0 15px rgba(0,175,209,0.3)' : 'none',
                    }}
                    onMouseEnter={e => { if (!isActive) { e.target.style.background = '#00afd1'; e.target.style.color = '#000'; e.target.style.borderColor = '#00afd1'; }}}
                    onMouseLeave={e => { if (!isActive) { e.target.style.background = 'transparent'; e.target.style.color = 'rgba(255,255,255,0.5)'; e.target.style.borderColor = 'rgba(255,255,255,0.1)'; }}}
                  >
                    {tab}
                  </button>
                );
              })}
              <div style={{ flex: 1 }} />
              <button
                onClick={() => { if (window.SFX) window.SFX.mute(); }}
                title={sfxMuted ? 'Sound off' : 'Sound on'}
                style={{
                  height: 32,
                  width: 32,
                  padding: 0,
                  borderRadius: 9999,
                  border: '1px solid rgba(255,255,255,0.1)',
                  background: 'transparent',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: 14,
                  color: sfxMuted ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.6)',
                  cursor: 'pointer',
                  transition: 'background 300ms ease, color 300ms ease, border-color 300ms ease',
                }}
                onMouseEnter={e => { e.target.style.background = 'rgba(255,255,255,0.1)'; e.target.style.color = '#fff'; }}
                onMouseLeave={e => { e.target.style.background = 'transparent'; e.target.style.color = sfxMuted ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.6)'; }}
              >
                {sfxMuted ? '🔇' : '🔊'}
              </button>
              <button
                onClick={() => { document.dispatchEvent(new CustomEvent('vibes-sync-disable')); document.dispatchEvent(new CustomEvent('vibes-logout-request')); }}
                style={{
                  height: 32,
                  padding: '0 14px',
                  borderRadius: 9999,
                  border: '1px solid rgba(255,255,255,0.1)',
                  background: 'transparent',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: 10,
                  fontFamily: "'Inter', sans-serif",
                  fontWeight: 500,
                  textTransform: 'uppercase',
                  letterSpacing: '0.15em',
                  color: 'rgba(255,255,255,0.5)',
                  cursor: 'pointer',
                  transition: 'background 300ms ease, color 300ms ease, border-color 300ms ease',
                }}
                onMouseEnter={e => { e.target.style.background = '#ef4444'; e.target.style.color = '#fff'; e.target.style.borderColor = '#ef4444'; }}
                onMouseLeave={e => { e.target.style.background = 'transparent'; e.target.style.color = 'rgba(255,255,255,0.5)'; e.target.style.borderColor = 'rgba(255,255,255,0.1)'; }}
              >
                LOGOUT
              </button>
            </div>
            {/* Content area */}
            <div style={{ flex: 1, position: 'relative', minHeight: 0 }}>
              <JulianScreenEmbed
                sessionActive={sessionActive}
                onFileSelect={handleFileSelect}
                onMenuTab={setMenuTab}
                noBorder
              />
              {/* Overlay for React-managed tabs — AnimatePresence crossfade */}
              <AnimatePresence mode="wait">
                {menuTab !== 'screen' && (
                  <motion.div
                    key={menuTab}
                    initial={{ opacity: 0, y: 6 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -6 }}
                    transition={{ duration: 0.2, ease: [0.165, 0.84, 0.44, 1] }}
                    style={{
                      position: 'absolute',
                      inset: 0,
                      zIndex: 15,
                      background: '#0c0c0c',
                      display: 'flex',
                      flexDirection: 'column',
                    }}
                  >
                    {menuTab === 'files' && (
                      <ScreenGridPanel
                        data={filesData}
                        rootLabel="memory"
                        onFileSelect={handleFileSelect}
                      />
                    )}
                    {menuTab === 'skills' && (
                      <ScreenGridPanel
                        data={skillsData}
                        rootLabel="skills"
                        onFileSelect={handleFileSelect}
                      />
                    )}
                    {menuTab === 'agents' && (
                      <div style={{
                        flex: 1,
                        display: 'flex',
                        flexDirection: 'column',
                        padding: '16px 24px',
                        minHeight: 0,
                        background: '#0c0c0c',
                      }}>
                        <AgentGrid
                          agents={agents}
                          activeAgent={activeAgent}
                          onSelectAgent={handleSelectAgent}
                          onSummon={handleSummon}
                          onWake={handleWake}
                          summoning={summoning}
                          fillContainer
                        />
                      </div>
                    )}
                    {menuTab === 'jobs' && (
                      <JobsPanel
                        database={database}
                        useLiveQuery={useLiveQuery}
                        getAuthHeaders={getAuthHeaders}
                      />
                    )}
                    {menuTab === 'browser' && (
                      <ArtifactViewer
                        activeArtifact={activeArtifact}
                        artifacts={artifacts}
                        onSelect={setActiveArtifact}
                        embedded
                      />
                    )}
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </div>
        </div>
      )}
    </>
  );
}

export default App;

      // App wrapper with Clerk auth gate (always required)
      function AppWrapper() {
        const config = window.__VIBES_CONFIG__;

        // Hook must be called unconditionally at top of component (Rules of Hooks)
        window.useVibesPanelEvents('Vibes');

        // Check for configuration errors
        if (!config?.clerkPublishableKey || config.clerkPublishableKey.startsWith('__')) {
          return <ConfigError message="Missing Clerk publishable key. Apps require authentication." />;
        }

        // Check if Clerk components loaded
        if (!window.ClerkFireproofProvider) {
          return <LoadingError error={window.__CLERK_LOAD_ERROR__ || 'Clerk components not available'} />;
        }

        const { ClerkFireproofProvider, SignedIn, SignedOut, SignInButton } = window.ClerkComponents;

        // Use shared components from window
        const AuthScreen = window.AuthScreen;
        const VibesButton = window.VibesButton;
        const RED = window.RED;

        const AuthGate = () => (
          <AuthScreen
            title="Sign in to continue"
            message="This app uses cloud sync and requires authentication."
            showCard={true}
          >
            <SignInButton mode="modal">
              <VibesButton variant={RED} buttonType="form">
                Sign In
              </VibesButton>
            </SignInButton>
          </AuthScreen>
        );

        return (
          <ClerkFireproofProvider
            publishableKey={config.clerkPublishableKey}
            config={{
              apiUrl: config.tokenApiUri,
              cloudUrl: config.cloudBackendUrl
            }}
          >
            <SignedOut>
              <AuthGate />
            </SignedOut>
            <SignedIn>
                <App />
            </SignedIn>
          </ClerkFireproofProvider>
        );
      }

      // Load Clerk components (required for all apps)
      async function initApp() {
        try {
          // Dynamic import of @fireproof/clerk package
          const clerkModule = await import("@fireproof/clerk");
          window.ClerkFireproofProvider = clerkModule.ClerkFireproofProvider;
          window.ClerkComponents = {
            ClerkFireproofProvider: clerkModule.ClerkFireproofProvider,
            SignedIn: clerkModule.SignedIn,
            SignedOut: clerkModule.SignedOut,
            SignInButton: clerkModule.SignInButton,
            UserButton: clerkModule.UserButton
          };
          // Export for user's App code
          window.SignedIn = clerkModule.SignedIn;
          window.SignedOut = clerkModule.SignedOut;
          window.SignInButton = clerkModule.SignInButton;
          window.UserButton = clerkModule.UserButton;
          // Export Fireproof hook for user's App code
          window.useFireproofClerk = clerkModule.useFireproofClerk;
        } catch (err) {
          console.error('Failed to load Clerk components:', err);
          window.__CLERK_LOAD_ERROR__ = err.message || String(err);
        }

        const rootElement = document.getElementById("container");
        ReactDOMClient.createRoot(rootElement).render(<AppWrapper />);
      }

      initApp();
    </script>

  </body>
</html>
