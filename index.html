<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Made on Vibes DIY</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet" />
    <link rel="icon" type="image/svg+xml" href="/assets/icons/favicon.svg" />
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png" />
    <link rel="icon" type="image/x-icon" href="/assets/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png" />
    <link rel="manifest" href="/assets/icons/site.webmanifest" />
    <meta name="theme-color" content="#FFD600" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Julian" />
    <script>globalThis.process = { env: { NODE_ENV: "production" } };</script>
    <script>
      // One-time IndexedDB wipe: clear corrupted Fireproof CRDT state.
      // Fireproof names its IDB databases after the ledger (e.g. "julian-chat-v2.data"),
      // not with a "fireproof" prefix. Wipe all IDB databases on version bump.
      // Bump DB_VERSION to re-trigger if corruption recurs.
      (function() {
        var DB_VERSION = 12;
        var KEY = 'fp_migration_v' + DB_VERSION;
        if (localStorage.getItem(KEY)) return;
        var dbs = indexedDB.databases ? indexedDB.databases() : Promise.resolve([]);
        dbs.then(function(databases) {
          if (databases.length === 0) {
            localStorage.setItem(KEY, Date.now());
            return;
          }
          var deleted = 0;
          databases.forEach(function(db) {
            var req = indexedDB.deleteDatabase(db.name);
            req.onsuccess = req.onerror = function() {
              deleted++;
              if (deleted === databases.length) {
                localStorage.setItem(KEY, Date.now());
                location.reload();
              }
            };
          });
        }).catch(function() {
          localStorage.setItem(KEY, Date.now());
        });
      })();
    </script>
    <script src="https://unpkg.com/@babel/standalone@7.26.0/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- JulianScreen client modules (must load in order: renderer creates window.JScreen, others attach to it) -->
    <script src="/julianscreen/client/renderer.js"></script>
    <script src="/julianscreen/client/sprites.js"></script>
    <script src="/julianscreen/client/tiles.js"></script>
    <script src="/julianscreen/client/text.js"></script>
    <script src="/julianscreen/client/input.js"></script>
    <script src="/julianscreen/client/effects.js"></script>
    <script src="/julianscreen/client/face.js"></script>
    <script src="/julianscreen/client/menu.js"></script>
    <script>
      // ── SoundManager singleton ─────────────────────────────────────────
      // Plain JS, no React. Lives on window.SFX for global access.
      // Follows the same pattern as JulianScreenWS — script-scope singleton.
      (function() {
        var SOUNDS = [
          'boot','shutdown','level-up','click','notification','success',
          'error','open','close','select','navigate','tab',
          'toggle-on','toggle-off','delete'
        ];
        function SoundManager(basePath) {
          this._muted = localStorage.getItem('julian-sfx-muted') === 'true';
          this._sounds = {};
          for (var i = 0; i < SOUNDS.length; i++) {
            var audio = new Audio(basePath + SOUNDS[i] + '.mp3');
            audio.preload = 'auto';
            audio.volume = 0.4;
            this._sounds[SOUNDS[i]] = audio;
          }
        }
        SoundManager.prototype.play = function(name) {
          if (this._muted) return;
          var source = this._sounds[name];
          if (!source) return;
          var clone = source.cloneNode();
          clone.volume = source.volume;
          clone.play().catch(function() {});
        };
        SoundManager.prototype.mute = function() {
          this._muted = !this._muted;
          localStorage.setItem('julian-sfx-muted', String(this._muted));
          document.dispatchEvent(new CustomEvent('julian-sfx-mute-changed', {
            detail: { muted: this._muted }
          }));
          return this._muted;
        };
        Object.defineProperty(SoundManager.prototype, 'isMuted', {
          get: function() { return this._muted; }
        });
        // Boot sound — plays once per page load, requires user gesture
        SoundManager.prototype.playBoot = function() {
          if (this._bootPlayed) return;
          this._bootPlayed = true;
          this.play('boot');
        };
        window.SFX = new SoundManager('/sfx/');
      })();
    </script>
    <style>
      :root {
        /* Core colors */
        --vibes-black: #0f172a;
        --vibes-white: #ffffff;
        --vibes-near-black: #1a1a1a;
        --vibes-cream: #fffff0;

        /* Gray scale */
        --vibes-gray-lightest: #f1f5f9;
        --vibes-gray-ultralight: #f8fafc;
        --vibes-gray-mid: #555555;

        /* Menu colors */
        --vibes-menu-bg: #CCCDC8;
        --vibes-menu-grid: rgba(255, 255, 255, 0.5);

        /* Button variant colors */
        --vibes-variant-blue: #009ACE;
        --vibes-variant-red: #DA291C;
        --vibes-variant-yellow: #eab308;
        --vibes-variant-gray: #6b7280;

        /* Button styling */
        --vibes-button-bg: var(--vibes-cream);
        --vibes-button-text: var(--vibes-near-black);
        --vibes-button-border: var(--vibes-near-black);
        --vibes-button-icon-bg: #fff;
        --vibes-button-icon-fill: #2a2a2a;

        /* Dark-aware button variants (for components using ignoreDarkMode=false) */
        --vibes-button-bg-dark-aware: var(--vibes-cream);
        --vibes-button-text-dark-aware: var(--vibes-near-black);
        --vibes-button-border-dark-aware: var(--vibes-near-black);
        --vibes-button-icon-bg-dark-aware: var(--vibes-white);

        /* Card colors */
        --vibes-card-bg: var(--vibes-cream);
        --vibes-card-text: var(--vibes-near-black);
        --vibes-card-border: var(--vibes-near-black);

        /* Status colors */
        --vibes-green: #22c55e;
        --vibes-red-accent: #ef4444;
        --vibes-yellow-accent: #eab308;
        --vibes-shadow-color: rgba(0, 0, 0, 0.2);

        /* Text colors */
        --vibes-text-primary: var(--vibes-near-black);

        /* Landing page theming (customize these for brand) */
        --landing-accent: #0f172a;
        --landing-accent-hover: #1e293b;

        /* Admin dashboard theming */
        --admin-bg: oklch(0.97 0.01 250);
        --admin-card-bg: white;
        --admin-text: #0f172a;
        --admin-text-muted: #64748b;
        --admin-accent: oklch(0.6 0.2 145);
        --admin-border: #0f172a;
        --admin-shadow: #0f172a;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --vibes-button-bg-dark-aware: #2a2a2a;
          --vibes-button-text-dark-aware: var(--vibes-gray-ultralight);
          --vibes-button-border-dark-aware: var(--vibes-gray-mid);
          --vibes-button-icon-bg-dark-aware: #404040;
        }
      }


      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      }
      #container {
        width: 100%;
        height: 100vh;
      }

      /* ── Screen panel design system ─────────────────────────────────────── */
      @keyframes screen-icon-glow {
        0%, 100% { filter: drop-shadow(0 0 2px rgba(250, 214, 1, 0.3)); }
        50% { filter: drop-shadow(0 0 4px rgba(250, 214, 1, 0.5)); }
      }
      .screen-icon-glow {
        animation: screen-icon-glow 3s ease-in-out infinite;
      }
      .screen-grid-item:hover .screen-icon-glow {
        opacity: 1 !important;
        transform: scale(1.05);
      }
      .screen-grid-item:hover .screen-grid-label {
        color: white !important;
      }
      .screen-panel-scroll::-webkit-scrollbar {
        width: 6px;
        background: #0c0c0c;
      }
      .screen-panel-scroll::-webkit-scrollbar-track {
        background-color: transparent;
      }
      .screen-panel-scroll::-webkit-scrollbar-thumb {
        background-color: #333;
        border-radius: 3px;
      }
      .screen-panel-scroll::-webkit-scrollbar-button {
        display: none;
      }

      /* ── Button press feedback ─────────────────────────────────────────── */
      button {
        touch-action: manipulation;
      }
      button:active {
        transform: scale(0.97);
      }

      /* ── Message entrance animation ────────────────────────────────────── */
      @keyframes message-enter {
        from { opacity: 0; transform: translateY(8px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .message-enter {
        animation: message-enter 200ms cubic-bezier(0.165, 0.84, 0.44, 1);
      }

      /* ── Reduced motion ────────────────────────────────────────────────── */
      @media (prefers-reduced-motion: reduce) {
        .screen-icon-glow { animation: none; }
        .screen-grid-item:hover .screen-icon-glow { transform: none; }
        .message-enter { animation: none; }
        button:active { transform: none; }
      }

      /* ── Hover effects only on hover-capable devices ───────────────────── */
      .screen-grid-item:hover .screen-icon-glow,
      .screen-grid-item:hover .screen-grid-label {
        /* Default: already defined above */
      }
      @media (hover: none) {
        .screen-grid-item:hover .screen-icon-glow {
          opacity: 0.8 !important;
          transform: none;
        }
        .screen-grid-item:hover .screen-grid-label {
          color: rgba(255,255,255,0.4) !important;
        }
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/stable/react@19.2.4",
          "react/jsx-runtime": "https://esm.sh/stable/react@19.2.4/jsx-runtime",
          "react/jsx-dev-runtime": "https://esm.sh/stable/react@19.2.4/jsx-dev-runtime",
          "react-dom": "https://esm.sh/stable/react-dom@19.2.4",
          "react-dom/client": "https://esm.sh/stable/react-dom@19.2.4/client",
          "multiformats": "https://esm.sh/stable/multiformats@13.3.1",
          "multiformats/": "https://esm.sh/stable/multiformats@13.3.1/",
          "@ipld/dag-cbor": "https://esm.sh/stable/@ipld/dag-cbor@9.2.2?external=multiformats",
          "@ipld/dag-json": "https://esm.sh/stable/@ipld/dag-json@10.2.3?external=multiformats",
          "@clerk/clerk-react": "https://esm.sh/stable/@clerk/clerk-react@5.59.2?external=react,react-dom",
          "use-fireproof": "/bundles/fireproof-vibes-bridge.js",
          "@fireproof/clerk": "/bundles/fireproof-vibes-bridge.js",
          "framer-motion": "https://esm.sh/stable/framer-motion@11?external=react,react-dom"
        }
      }
    </script>
    <!-- Connect configuration - populated by assemble.js from .env -->
    <script>
      window.__VIBES_CONFIG__ = {
        tokenApiUri: "https://connect-share.exe.xyz/api/",
        cloudBackendUrl: "fpcloud://connect-share.exe.xyz?protocol=wss",
        // Must match VITE_CLERK_PUBLISHABLE_KEY in server/julian-bridge.service
        clerkPublishableKey: "pk_test_aW50ZXJuYWwtZGluZ28tMjguY2xlcmsuYWNjb3VudHMuZGV2JA"
      };
    </script>
    <!-- Load React globally for menu components -->
    <script type="module">
      import * as React from "react";
      window.React = React;
    </script>
    <!-- Load Framer Motion for UI animations -->
    <script type="module">
      import { motion, AnimatePresence, useReducedMotion } from "framer-motion";
      window.motion = motion;
      window.AnimatePresence = AnimatePresence;
      window.useReducedMotion = useReducedMotion;
    </script>
    <!-- Vibes component library (auto-generated, rarely changes) -->
    <script type="text/babel" src="/vibes.jsx"></script>
    <!-- Chat UI components (PixelFace, MessageBubble, SetupScreen, etc.) -->
    <script type="text/babel" src="/chat.jsx"></script>
    <!-- App component + initialization -->
    <script type="text/babel" data-type="module">
      import ReactDOMClient from "react-dom/client";
      import React, { useState, useEffect, useRef, useCallback, useMemo } from "react";
      import { useFireproofClerk } from "use-fireproof";

      // Pull chat.jsx window exports into module scope
      const { ArtifactViewer, JulianScreenEmbed, SetupScreen, ChatInput,
              MessageBubble, ToolCallBlock, ThinkingDots, StatusDots,
              PixelFace, ConfigError, LoadingError,
              AgentGrid, AgentFaceHeader, EggHatch,
              hashNameToFaceVariant, AGENT_COLORS,
              JobsPanel, ScreenGridPanel,
              motion: _motion, AnimatePresence: _AP } = window;
      const motion = _motion || { div: 'div' };
      const AnimatePresence = _AP || (({ children }) => children);

/* ── Artifact catalog ─────────────────────────────────────────────────────
 * Julian's memory catalog is a single XML document (catalog.xml) containing
 * all artifact metadata and stripped content. On first startSession, it's
 * fetched once and stored as a single Fireproof record — one write instead
 * of 28. The XML is static, generated at build time by scripts/build-catalog.js.
 *
 * To rebuild: bun scripts/build-catalog.js
 * ──────────────────────────────────────────────────────────────────────── */

// Parse catalog XML into metadata array for session start
function parseCatalogXML(xmlString) {
  const doc = new DOMParser().parseFromString(xmlString, "text/xml");
  return [...doc.querySelectorAll("artifact")].map(el => ({
    filename: el.getAttribute("filename"),
    dir: el.getAttribute("dir"),
    title: el.getAttribute("title"),
    category: el.getAttribute("category"),
    chapter: el.getAttribute("chapter"),
    description: el.getAttribute("description"),
  }));
}

// Ensure catalog record exists in Fireproof, fetch and store if missing
async function ensureCatalog(database) {
  try {
    const existing = await database.query("type", { key: "artifact-catalog" });
    if (existing.rows.length > 0) {
      const doc = existing.rows[0].doc || existing.rows[0].value;
      console.log("[catalog] Found existing catalog record");
      return parseCatalogXML(doc.content);
    }
  } catch (err) {
    console.warn("[catalog] Query failed, will fetch:", err);
  }

  try {
    const res = await fetch("/catalog.xml");
    if (!res.ok) throw new Error("HTTP " + res.status);
    const xml = await res.text();
    await resilientPut(database, { type: "artifact-catalog", content: xml, createdAt: new Date().toISOString() });
    console.log("[catalog] Fetched and stored catalog record");
    return parseCatalogXML(xml);
  } catch (err) {
    console.warn("[catalog] Failed to fetch catalog.xml:", err);
    return [];
  }
}

/* ── Resilient database writes ──────────────────────────────────────── */
// Safety net for runtime puts. Retries on transient WriteQueueImpl errors
// (cloud store attachment race). In normal operation after boot, never triggers.
async function resilientPut(database, doc, maxRetries = 3) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await database.put(doc);
    } catch (err) {
      const isStoreError = err?.message?.includes('WriteQueueImpl')
        || err?.message?.includes('stores');
      if (!isStoreError || attempt === maxRetries) throw err;
      const delay = Math.pow(2, attempt) * 1000;
      console.warn(`[resilientPut] Retry ${attempt + 1}/${maxRetries} in ${delay}ms`);
      await new Promise(r => setTimeout(r, delay));
    }
  }
}
window.resilientPut = resilientPut;

/* ── SSE stream reader ────────────────────────────────────────────────── */

/* ── Event Log Subscription ────────────────────────────────────────────── */
// Replaces per-request SSE with a single persistent EventSource connection.
// Events flow: Claude stdout → server event log → EventSource → React state.

let _eventSource = null;
// Skip historical replay on first page load to avoid reprocessing a large event backlog.
// We persist the last seen id per-tab and resume from there on reconnect.
let _lastEventId = (() => {
  try {
    const raw = sessionStorage.getItem('julian:last-event-id');
    const parsed = raw == null ? NaN : parseInt(raw, 10);
    return Number.isFinite(parsed) ? parsed : Number.MAX_SAFE_INTEGER;
  } catch {
    return Number.MAX_SAFE_INTEGER;
  }
})();
let _eventHandlers = {
  onClaudeText: null,
  onClaudeResult: null,
  onClaudeToolResult: null,
  onSessionStart: null,
  onSessionEnd: null,
  onAgentRegistered: null,
  onAgentStatus: null,
  onArtifactWritten: null,
  onAgentMessage: null,
  onServerError: null,
  onUserMessage: null,
};

// Lazy default: reads status field, falls back to legacy hatching boolean
function getAgentStatus(doc) {
  if (doc.status) return doc.status;
  return doc.hatching ? 'hatching' : 'sleeping';
}
window.getAgentStatus = getAgentStatus;

// Standalone auth header helper (usable outside React components)
async function getClerkAuthHeaders() {
  for (let i = 0; i < 10; i++) {
    if (window.Clerk?.session) break;
    await new Promise(r => setTimeout(r, 500));
  }
  try {
    const token = await window.Clerk?.session?.getToken();
    if (!token) return null;
    return { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}`, 'X-Authorization': `Bearer ${token}` };
  } catch (err) {
    console.error('[Auth] Clerk getToken() error:', err);
    return null;
  }
}

function connectEventSource(getAuthHeaders) {
  if (_eventSource) {
    _eventSource.close();
    _eventSource = null;
  }

  // EventSource doesn't support custom headers, so we use fetch-based SSE
  let cancelled = false;
  let wasConnected = false;

  // Phase 5a: Sleep all alive agents locally on disconnect
  async function sleepAgentsOnDisconnect() {
    const db = window._julianDB;
    if (!db) return;
    try {
      const { rows } = await db.query('type', { key: 'agent-identity' });
      for (const row of rows) {
        const doc = row.doc || row.value;
        if (getAgentStatus(doc) === 'alive') {
          await resilientPut(db, { ...doc, status: 'sleeping' });
        }
      }
      console.log('[EventSource] Disconnected — transitioned alive agents to sleeping');
    } catch (e) {
      console.warn('[EventSource] Failed to sleep agents on disconnect:', e);
    }
  }

  async function connect() {
    if (cancelled) return;
    const headers = await getAuthHeaders();
    if (!headers || cancelled) return;

    const idBeforeConnect = _lastEventId;
    let firstIdSeen = false;

    try {
      const url = '/api/events?after=' + _lastEventId;
      const response = await fetch(url, { headers });
      if (!response.ok || cancelled) return;

      wasConnected = true;
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let sseBuffer = '';

      while (!cancelled) {
        const { done, value } = await reader.read();
        if (done) break;

        sseBuffer += decoder.decode(value, { stream: true });
        const lines = sseBuffer.split('\n');
        sseBuffer = lines.pop() || '';

        for (const line of lines) {
          if (line.startsWith('id: ')) {
            const newId = parseInt(line.slice(4), 10);

            // Phase 5c: Detect large gap on reconnect — request full state
            if (!firstIdSeen && idBeforeConnect > 0 && newId > idBeforeConnect + 100) {
              console.warn('[EventSource] Large event gap detected (' + idBeforeConnect + ' → ' + newId + '), requesting full state');
              fetch('/api/ledger-reset', { method: 'POST', headers })
                .catch(e => console.warn('[EventSource] Failed to signal ledger-reset:', e));
            }
            firstIdSeen = true;

            _lastEventId = newId;
            try { sessionStorage.setItem('julian:last-event-id', String(newId)); } catch {}
            continue;
          }
          if (!line.startsWith('data: ')) continue;
          try {
            const event = JSON.parse(line.slice(6));
            dispatchEvent(event);
          } catch (parseErr) {
            // heartbeat or malformed — skip
          }
        }
      }
    } catch (err) {
      console.warn('[EventSource] Connection error:', err);
    }

    // Phase 5a: On disconnect, sleep agents locally
    if (wasConnected && !cancelled) {
      sleepAgentsOnDisconnect();
    }

    // Auto-reconnect after 2s
    if (!cancelled) {
      setTimeout(() => connect(), 2000);
    }
  }

  connect();

  // Return a close function
  return () => { cancelled = true; };
}

function dispatchEvent(event) {
  // Broadcast on window so any component (e.g. JobForm) can listen
  window.dispatchEvent(new CustomEvent('julian:' + event.type, { detail: event }));
  const h = _eventHandlers;
  switch (event.type) {
    case 'claude_text':
      if (h.onClaudeText) h.onClaudeText(event);
      break;
    case 'claude_result':
      if (h.onClaudeResult) h.onClaudeResult(event);
      break;
    case 'claude_tool_result':
      if (h.onClaudeToolResult) h.onClaudeToolResult(event);
      break;
    case 'session_start':
      if (h.onSessionStart) h.onSessionStart(event);
      break;
    case 'session_end':
      if (h.onSessionEnd) h.onSessionEnd(event);
      break;
    case 'agent_registered':
      if (h.onAgentRegistered) h.onAgentRegistered(event);
      break;
    case 'agent_status':
      if (h.onAgentStatus) h.onAgentStatus(event);
      break;
    case 'agent_message':
      if (h.onAgentMessage) h.onAgentMessage(event);
      break;
    case 'artifact_written':
      if (h.onArtifactWritten) h.onArtifactWritten(event);
      break;
    case 'ui_action':
      window.dispatchEvent(new CustomEvent('julian:ui-action', {
        detail: { target: event.target, action: event.action, data: event.data }
      }));
      break;
    case 'server_error':
      if (h.onServerError) h.onServerError(event);
      break;
    case 'user_message':
      if (h.onUserMessage) h.onUserMessage(event);
      break;
  }
}

/* ── Perf Debug (activate with ?perfDebug=1) ─────────────────────────────── */

const PERF_DEBUG = new URLSearchParams(location.search).has('perfDebug');
window.PERF_DEBUG = PERF_DEBUG;
function perfLog(...args) { if (PERF_DEBUG) console.log('[PERF]', ...args); }

/* ── Identity Stabilization (canonical impl in shared/utils.js) ──────────── */

const AGENT_SIGNIFICANT_FIELDS = ['name', 'status', 'gridPosition', 'jobId', 'dormant', 'color', 'colorName', 'gender', 'faceVariant'];

function stabilizeDocsByKey(prev, next, keyFn, significantFields) {
  if (!prev || !next) return next || [];
  if (prev === next) return prev;
  const prevMap = new Map();
  for (const doc of prev) {
    const key = keyFn(doc);
    if (key != null) prevMap.set(key, doc);
  }
  let allSame = prev.length === next.length;
  const result = next.map((doc, i) => {
    const key = keyFn(doc);
    const prevDoc = key != null ? prevMap.get(key) : undefined;
    if (!prevDoc) { allSame = false; return doc; }
    const changed = significantFields.some(f => prevDoc[f] !== doc[f]);
    if (changed) { allSame = false; return doc; }
    if (prevDoc !== prev[i]) allSame = false;
    return prevDoc;
  });
  return allSame ? prev : result;
}

function deriveStableAgents(prevAgents, docs) {
  if (!docs || docs.length === 0) return prevAgents && prevAgents.length === 0 ? prevAgents : [];
  const next = docs.map(doc => ({ ...doc, _status: getAgentStatus(doc) }));
  if (!prevAgents || prevAgents.length === 0) return next;
  const prevMap = new Map();
  for (const a of prevAgents) { if (a.name) prevMap.set(a.name, a); }
  let allSame = prevAgents.length === next.length;
  const result = next.map((agent, i) => {
    const prev = agent.name ? prevMap.get(agent.name) : undefined;
    if (!prev) { allSame = false; return agent; }
    const changed = AGENT_SIGNIFICANT_FIELDS.some(f => prev[f] !== agent[f])
      || prev._status !== agent._status;
    if (changed) { allSame = false; return agent; }
    if (prev !== prevAgents[i]) allSame = false;
    return prev;
  });
  return allSame ? prevAgents : result;
}

/* ── Main App ────────────────────────────────────────────────────────────── */

function App({ bootData }) {
  const { database, useLiveQuery, localOnly } = bootData;

  const { docs: persistedMessages } = useLiveQuery("type", { key: "message" });

  const [liveAssistant, setLiveAssistant] = useState(null);
  const [streaming, setStreaming] = useState(false);
  const [connected, setConnected] = useState(false);
  const [setupNeeded, setSetupNeeded] = useState(null);
  const [sessionActive, setSessionActive] = useState(false);
  const [wakingUp, setWakingUp] = useState(false);
  const [serverSessionId, setServerSessionId] = useState(null);
  const messagesEndRef = useRef(null);
  const [artifacts, setArtifacts] = useState([]);
  const [activeArtifact, setActiveArtifact] = useState('');
  const [menuDataLoaded, setMenuDataLoaded] = useState(false);
  const [filesData, setFilesData] = useState(null);
  const [skillsData, setSkillsData] = useState(null);

  // Agent Teams state
  const [activeAgent, setActiveAgent] = useState(null);
  const [summoning, setSummoning] = useState(false);
  const [menuTab, setMenuTab] = useState('files');

  // Jobs panel state — lifted to App so state survives tab switches (JobsPanel unmounts)
  // AgentGrid React.memo prevents keystroke cascades that motivated the original move to local state
  const [jobView, setJobView] = useState('list');
  const [selectedJob, setSelectedJob] = useState(null);
  const [jobDraft, setJobDraft] = useState(null);
  const [sfxMuted, setSfxMuted] = useState(window.SFX?.isMuted ?? false);
  useEffect(() => {
    const handler = (e) => setSfxMuted(e.detail.muted);
    document.addEventListener('julian-sfx-mute-changed', handler);
    return () => document.removeEventListener('julian-sfx-mute-changed', handler);
  }, []);

  // Query agent identities from Fireproof
  const { docs: rawAgentDocs } = useLiveQuery("type", { key: "agent-identity" });

  // Stabilize agent docs — preserve references when only non-significant fields change
  const stableAgentDocsRef = useRef([]);
  const agentDocs = useMemo(() => {
    const stable = stabilizeDocsByKey(
      stableAgentDocsRef.current, rawAgentDocs || [],
      doc => doc._id, AGENT_SIGNIFICANT_FIELDS
    );
    stableAgentDocsRef.current = stable;
    return stable;
  }, [rawAgentDocs]);

  // Query jobs from Fireproof
  const { docs: jobDocs } = useLiveQuery("type", { key: "job" });
  const openJobs = useMemo(() =>
    (jobDocs || []).filter(j => j.status === 'open'),
    [jobDocs]
  );

  // Derive stable agents — preserves references for unchanged agents
  const stableAgentsRef = useRef([]);
  const agents = useMemo(() => {
    const stable = deriveStableAgents(stableAgentsRef.current, agentDocs);
    stableAgentsRef.current = stable;
    return stable;
  }, [agentDocs]);

  const activeAgentObj = useMemo(() => {
    if (!activeAgent) return null;
    return agents.find(a => a.name === activeAgent) || null;
  }, [activeAgent, agents]);

  // ── Perf counters (debug only) ──────────────────────────────────────────
  const perfRef = useRef({ renders: 0, rawChanged: 0, stableChanged: 0, lastAgents: null, lastRawDocs: null, lastSample: Date.now() });
  if (PERF_DEBUG) {
    perfRef.current.renders++;
    const p = perfRef.current;
    const rawDocsChanged = p.lastRawDocs !== rawAgentDocs;
    const agentsChanged = p.lastAgents !== agents;
    if (rawDocsChanged) p.rawChanged++;
    if (agentsChanged) p.stableChanged++;
    p.lastRawDocs = rawAgentDocs;
    p.lastAgents = agents;
    if (rawDocsChanged) {
      perfLog('App render #' + p.renders, {
        rawDocsChanged, stableAgentsChanged: agentsChanged,
        suppressed: rawDocsChanged && !agentsChanged,
        agentDocsLen: agentDocs?.length
      });
    }
  }
  useEffect(() => {
    if (!PERF_DEBUG) return;
    const iv = setInterval(() => {
      const p = perfRef.current;
      const elapsed = (Date.now() - p.lastSample) / 1000;
      perfLog('App rate:', (p.renders / elapsed).toFixed(2) + '/sec', 'total:', p.renders);
      p.renders = 0;
      p.lastSample = Date.now();
    }, 2000);
    return () => clearInterval(iv);
  }, []);

  const handleSelectAgent = useCallback((agentName) => {
    setActiveAgent(agentName);
    setLiveAssistant(null);
  }, []);

  // Unregister any leftover service worker (PWA removed during active dev)
  useEffect(() => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(regs =>
        regs.forEach(r => r.unregister())
      );
    }
  }, []);

  // ── EventSource: persistent connection to server event log ──────────────
  const eventSourceCloseRef = useRef(null);
  const liveBlocksRef = useRef([]);
  const lastMsgIdRef = useRef(null);
  const notifiedArrivalRef = useRef(false);

  // Refs for values read inside event handlers and callbacks — avoids
  // re-registering handlers when these change, which would break memoization.
  // Keep raw docs here for event handlers that need freshest non-render fields
  // (e.g. timestamps/metadata that are intentionally excluded from stabilization).
  const agentDocsRef = useRef(rawAgentDocs || []);
  agentDocsRef.current = rawAgentDocs || [];
  const activeAgentRef = useRef(activeAgent);
  activeAgentRef.current = activeAgent;
  const refreshMenuDataRef = useRef(null);
  const summoningRef = useRef(summoning);
  summoningRef.current = summoning;
  const sessionActiveRef = useRef(sessionActive);
  sessionActiveRef.current = sessionActive;

  useEffect(() => {
    // Wire up event handlers that update React state
    _eventHandlers.onClaudeText = (event) => {
      const blocks = (event.content || []).map(block => {
        if (block.type === 'text') {
          const cleaned = block.text.split('\n').filter(l => !l.startsWith('[UI_ACTION]')).join('\n');
          return { type: 'text', text: cleaned };
        }
        if (block.type === 'tool_use') return { type: 'tool_use', name: block.name, input: block.input };
        return block;
      });
      liveBlocksRef.current = blocks;
      if (!notifiedArrivalRef.current) { window.SFX?.play('notification'); notifiedArrivalRef.current = true; }
      // Server may send empty string '' for messageId — treat as missing.
      // Generate a synthetic ID so the message always gets persisted.
      const rawMsgId = event.messageId || null;
      const msgId = rawMsgId || lastMsgIdRef.current || ('synthetic-' + Date.now());
      lastMsgIdRef.current = msgId;
      setLiveAssistant(prev => prev ? { ...prev, blocks, messageId: msgId, thinking: false, streaming: true } : {
        id: 'live-' + Date.now(), role: 'assistant', blocks, messageId: msgId, thinking: false, streaming: true
      });

      // Persist each assistant turn immediately so multi-turn messages don't vanish
      // Use messageId as _id to prevent duplicates if the same event re-fires
      if (blocks.length > 0) {
        const _activeAgent = activeAgentRef.current;
        const _agentDocs = agentDocsRef.current;
        const speakerDoc = _activeAgent
          ? (_agentDocs || []).find(a => a.name === _activeAgent)
          : null;
        resilientPut(database, {
          _id: 'msg-' + msgId,
          type: 'message', category: 'transcript', role: 'assistant',
          speakerType: 'agent', speakerName: _activeAgent || 'Julian',
          agentName: _activeAgent || undefined,
          gridPosition: speakerDoc?.gridPosition ?? undefined,
          text: '', blocks,
          createdAt: new Date().toISOString(), serverSessionId,
        }).catch(err => console.error('[chat] Fireproof put failed:', err));
      }
    };

    _eventHandlers.onClaudeResult = async (event) => {
      // Intermediate turn results (tool use) — ignore, don't finalize
      if (event.subtype && event.subtype !== 'success') {
        return;
      }
      const finalBlocks = liveBlocksRef.current.length > 0
        ? liveBlocksRef.current
        : (event.resultText ? [{ type: 'text', text: event.resultText.split('\n').filter(l => !l.startsWith('[UI_ACTION]')).join('\n') }] : []);
      window.SFX?.play('success');
      setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);

      // Determine the definitive doc ID for this message
      const msgId = lastMsgIdRef.current || ('synthetic-' + Date.now());
      const docId = 'msg-' + msgId;

      // Final persistence write — awaited, so we KNOW it landed before clearing live state.
      // This overwrites any intermediate writes from onClaudeText with the complete final blocks.
      const _activeAgent = activeAgentRef.current;
      const _agentDocs = agentDocsRef.current;
      const speakerDoc = _activeAgent
        ? (_agentDocs || []).find(a => a.name === _activeAgent)
        : null;

      if (finalBlocks.length > 0) {
        try {
          // Fetch existing doc to get _rev (onClaudeText may have already created it)
          let existing = null;
          try { existing = await database.get(docId); } catch (_) { /* not found — fine */ }
          await resilientPut(database, {
            ...(existing ? { _id: existing._id, _rev: existing._rev } : { _id: docId }),
            type: 'message', category: 'transcript', role: 'assistant',
            speakerType: 'agent', speakerName: _activeAgent || 'Julian',
            agentName: _activeAgent || undefined,
            gridPosition: speakerDoc?.gridPosition ?? undefined,
            text: '', blocks: finalBlocks,
            createdAt: existing?.createdAt || new Date().toISOString(), serverSessionId,
          });
        } catch (err) {
          console.error('[chat] Final Fireproof put failed:', err);
        }
      }

      // Auto-catalog: detect Write tool for memory/*.html
      const writeBlocks = finalBlocks.filter(b =>
        b.type === 'tool_use' && b.name === 'Write' &&
        b.input?.file_path?.includes('memory/') &&
        b.input?.file_path?.endsWith('.html')
      );
      for (const wb of writeBlocks) {
        const filename = wb.input.file_path.split('/').pop();
        setTimeout(async () => {
          try {
            const resp = await fetch('/api/artifacts/' + encodeURIComponent(filename));
            if (!resp.ok) return;
            const html = await resp.text();
            const dpParser = new DOMParser();
            const parsed = dpParser.parseFromString(html, 'text/html');
            const description = parsed.querySelector('meta[name="artifact-description"]')?.content;
            const artCategory = parsed.querySelector('meta[name="artifact-category"]')?.content || 'knowledge';
            const chapter = parsed.querySelector('meta[name="artifact-chapter"]')?.content || '';
            if (description) {
              const existing = await database.query('type', { key: 'artifact' });
              const entry = (existing.rows || []).find(r => (r.doc || r.value).filename === filename);
              if (entry) {
                const existingDoc = entry.doc || entry.value;
                await resilientPut(database, { ...existingDoc, description, category: artCategory, chapter });
              } else {
                await resilientPut(database, { type: 'artifact', category: artCategory, filename, description, chapter, createdAt: new Date().toISOString() });
              }
            }
          } catch (e) {
            console.warn('[catalog] Failed to auto-catalog:', filename, e);
          }
        }, 2500);
      }

      // Persistence confirmed — clear live state immediately.
      // No timers, no absorption detection. The write landed, so useLiveQuery
      // will pick it up on the next render cycle and displayMessages will show
      // the persisted copy.
      setConnected(true);
      notifiedArrivalRef.current = false;
      setLiveAssistant(null);
      setStreaming(false);
      liveBlocksRef.current = [];
      lastMsgIdRef.current = null;
      if (typeof refreshMenuDataRef.current === 'function') refreshMenuDataRef.current();
    };

    _eventHandlers.onSessionEnd = async (event) => {
      console.log('[EventSource] Session ended:', event.reason);
      // Transition all alive agents to sleeping
      try {
        const { rows } = await database.query('type', { key: 'agent-identity' });
        for (const row of rows) {
          const doc = row.doc || row.value;
          if (getAgentStatus(doc) === 'alive') {
            await resilientPut(database, { ...doc, status: 'sleeping' });
          }
        }
      } catch (e) {
        console.warn('[EventSource] Failed to sleep agents on session end:', e);
      }
      setSessionActive(false);
      setConnected(false);
      setStreaming(false);
      setServerSessionId(null);
      setLiveAssistant(null);
      setMenuTab('files');
    };

    _eventHandlers.onSessionStart = (event) => {
      console.log('[EventSource] Session started, PID:', event.pid);
      setSessionActive(true);
      setConnected(true);
    };

    _eventHandlers.onAgentRegistered = async (event) => {
      const a = event.agent;
      if (!a?.name || a.gridPosition == null) return;
      try {
        const _id = `agent-identity:${a.gridPosition}`;
        const existing = await database.get(_id).catch(() => null);
        await resilientPut(database, {
          ...(existing || {}),
          _id,
          type: 'agent-identity',
          category: 'identity',
          status: 'alive',
          name: a.name,
          color: a.color,
          colorName: a.colorName,
          gender: a.gender,
          gridPosition: a.gridPosition,
          faceVariant: a.faceVariant,
          individuationArtifact: a.individuationArtifact,
          lastAliveAt: new Date(event.ts).toISOString(),
          lastSessionId: event.sessionId,
          createdAt: existing?.createdAt || a.createdAt,
        });
        window.SFX?.play('select');
        console.log('[EventSource] Agent registered:', a.name, 'at seat', a.gridPosition);
      } catch (e) {
        console.warn('[EventSource] Failed to save agent:', e);
      }
    };

    _eventHandlers.onAgentStatus = async (event) => {
      try {
        const agentMap = {};
        for (const a of (event.agents || [])) {
          if (a.gridPosition != null) agentMap[a.gridPosition] = a;
        }

        // Update or create agent docs (upsert — self-healing)
        for (const [pos, agent] of Object.entries(agentMap)) {
          const _id = `agent-identity:${pos}`;
          const existing = await database.get(_id).catch(() => null);

          if (existing) {
            // Phase 1a: refuse alive transition for nameless docs
            if (!existing.name && agent.status === 'alive') {
              console.warn('[EventSource] Skipping alive transition for nameless doc at seat', pos);
              continue;
            }
            // Update status if changed
            if (getAgentStatus(existing) !== agent.status) {
              await resilientPut(database, {
                ...existing,
                status: agent.status,
                lastAliveAt: new Date(event.ts).toISOString(),
                lastSessionId: event.sessionId,
              });
            }
          } else if (agent.name) {
            // Create from status event data (self-healing)
            await resilientPut(database, {
              _id,
              type: 'agent-identity',
              category: 'identity',
              status: agent.status,
              name: agent.name,
              color: agent.color,
              colorName: agent.colorName,
              gender: agent.gender,
              faceVariant: agent.faceVariant,
              gridPosition: parseInt(pos),
              lastAliveAt: new Date(event.ts).toISOString(),
              lastSessionId: event.sessionId,
              createdAt: new Date().toISOString(),
            });
            console.log('[EventSource] Self-healed agent doc at seat', pos, agent.name);
          }
        }

        // Transition agents not in status to sleeping
        const { rows } = await database.query('type', { key: 'agent-identity' });
        for (const row of rows) {
          const doc = row.doc || row.value;
          if (!agentMap[doc.gridPosition] && getAgentStatus(doc) === 'alive') {
            await resilientPut(database, { ...doc, status: 'sleeping' });
          }
        }
      } catch (e) {
        console.warn('[EventSource] Failed to handle agent_status:', e);
      }
    };

    _eventHandlers.onServerError = (event) => {
      console.error('[EventSource] Server error:', event.message, event.code);
      window.SFX?.play('error');
      setLiveAssistant(prev => prev ? { ...prev, blocks: [{ type: 'text', text: 'Error: ' + event.message }], thinking: false, streaming: false } : null);
      setStreaming(false);
    };

    _eventHandlers.onArtifactWritten = () => {
      // Refresh menu data when artifacts are written
      if (typeof refreshMenuDataRef.current === 'function') refreshMenuDataRef.current();
    };

    _eventHandlers.onAgentMessage = async (event) => {
      const text = (event.content || [])
        .filter(b => b.type === 'text')
        .map(b => b.text)
        .join('\n');
      if (!text) return;

      // Find the agent's grid position for transcript scoping
      const _agentDocs = agentDocsRef.current;
      const agentDoc = (_agentDocs || []).find(a => a.name === event.agentName);
      const gridPos = agentDoc?.gridPosition;

      // Persist to Fireproof with a deterministic _id so we can track absorption
      const agentMsgId = 'agent-msg-' + Date.now() + '-' + Math.random().toString(36).slice(2, 8);
      try {
        await resilientPut(database, {
          _id: agentMsgId,
          type: 'message',
          category: 'transcript',
          role: 'assistant',
          speakerType: 'agent',
          speakerName: event.agentName,
          agentName: event.agentName,
          gridPosition: gridPos ?? undefined,
          text,
          blocks: [{ type: 'text', text }],
          createdAt: new Date().toISOString(),
          serverSessionId,
        });
      } catch (e) {
        console.warn('[EventSource] Failed to persist agent message:', e);
      }

      // If this agent is currently selected, show as live briefly then clear.
      // The resilientPut above already succeeded, so the persisted doc will
      // appear in useLiveQuery on the next render cycle.
      if (activeAgentRef.current === event.agentName) {
        window.SFX?.play('notification');
        setLiveAssistant({
          id: agentMsgId,
          role: 'assistant',
          blocks: [{ type: 'text', text }],
          thinking: false,
          streaming: false,
        });
        // Clear after a short delay to let useLiveQuery catch up
        setTimeout(() => {
          setLiveAssistant(null);
          setStreaming(false);
        }, 300);
      }
    };
  }, [database, serverSessionId]);

  // Connect/disconnect EventSource based on auth readiness
  useEffect(() => {
    const close = connectEventSource(getAuthHeaders);
    eventSourceCloseRef.current = close;
    return () => { if (close) close(); };
  }, [getAuthHeaders]);

  // Listen for programmatic chat sends (e.g. from job form UI actions)
  // Use refs to avoid re-registering the listener on every sendMessage/streaming change
  const sendMessageRef = useRef(null);
  const streamingRef = useRef(streaming);
  streamingRef.current = streaming;
  useEffect(() => {
    const handler = (e) => {
      const msg = e.detail?.message;
      if (msg && sessionActive && !streamingRef.current && typeof sendMessageRef.current === 'function') {
        sendMessageRef.current(msg);
      }
    };
    window.addEventListener('julian:send-chat', handler);
    return () => window.removeEventListener('julian:send-chat', handler);
  }, [sessionActive]);

  // Auth headers — delegates to standalone function (shared with BootScreen)
  const getAuthHeaders = useCallback(() => getClerkAuthHeaders(), []);

  const refreshMenuData = useCallback(async () => {
    try {
      const headers = await getAuthHeaders();
      if (!headers) return;

      const [artifactsRes, skillsRes, agentsRes] = await Promise.allSettled([
        fetch('/api/artifacts', { headers }),
        fetch('/api/skills', { headers }),
        fetch('/api/agents', { headers }),
      ]);

      if (artifactsRes.status === 'fulfilled' && artifactsRes.value.ok) {
        const data = await artifactsRes.value.json();
        // Flatten tree into list for ArtifactViewer dropdown (HTML files with path-qualified names)
        function flattenTree(entries, prefix) {
          const result = [];
          for (const e of entries) {
            if (e.type === 'folder' && e.children) {
              result.push(...flattenTree(e.children, prefix ? prefix + '/' + e.name : e.name));
            } else if (e.type === 'file' && e.name.endsWith('.html')) {
              const fullName = prefix ? prefix + '/' + e.name : e.name;
              result.push({ name: fullName, modified: e.modified });
            }
          }
          return result;
        }
        const files = flattenTree(data.entries || [], '');
        setArtifacts(files);
        setFilesData(data);
        if (window.JScreen?.setMenuData) window.JScreen.setMenuData('files', data);
      }
      if (skillsRes.status === 'fulfilled' && skillsRes.value.ok) {
        const data = await skillsRes.value.json();
        setSkillsData(data);
        if (window.JScreen?.setMenuData) window.JScreen.setMenuData('skills', data);
      }
      if (agentsRes.status === 'fulfilled' && agentsRes.value.ok) {
        const data = await agentsRes.value.json();
        if (window.JScreen?.setMenuData) window.JScreen.setMenuData('agents', data);
      }
      setMenuDataLoaded(true);
    } catch (err) {
      console.warn('[Menu] refresh failed:', err);
    }
  }, [getAuthHeaders]);
  refreshMenuDataRef.current = refreshMenuData;

  // Fetch menu data on mount
  useEffect(() => {
    refreshMenuData();
  }, [refreshMenuData]);

  // Boot-time effects (catalog seed, hatching expiry, ledger-meta) now run in BootScreen.

  // When session becomes active, switch to screen tab to show Julian's avatar
  useEffect(() => {
    if (sessionActive) setMenuTab('screen');
  }, [sessionActive]);

  // Handle file selection from JulianScreen menu (filename may include path like "shared/foo.html")
  const handleFileSelect = useCallback((filename) => {
    // Ensure it's in the artifacts list
    setArtifacts(prev => {
      if (prev.some(f => f.name === filename)) return prev;
      return [...prev, { name: filename, modified: Date.now() }];
    });
    setActiveArtifact(filename);
    // HTML files can be rendered — switch to browser tab automatically
    if (filename.endsWith('.html')) {
      setMenuTab('browser');
    }
  }, []);

  useEffect(() => {
    let cancelled = false;
    const tryInit = async () => {
      const headers = await getAuthHeaders();
      if (!headers) {
        if (!cancelled) setTimeout(tryInit, 500);
        return;
      }
      try {
        const r = await fetch('/api/health', { headers });
        if (!r.ok) {
          // Auth failed or server error — show setup screen so user can re-auth
          if (!cancelled) { setConnected(false); setSetupNeeded(true); }
          return;
        }
        const data = await r.json();
        if (!cancelled) {
          setSessionActive(data.sessionActive ?? false);
          setConnected(data.sessionActive ?? false);
          setSetupNeeded(data.needsSetup ?? false);
          if (data.sessionId) setServerSessionId(data.sessionId);
          if (data.version) window.__julianVersion = data.version;
        }
      } catch {
        if (!cancelled) {
          setConnected(false);
          setSetupNeeded(true);
        }
      }
    };
    tryInit();
    return () => { cancelled = true; };
  }, [getAuthHeaders]);


  // Poll health every 10s to detect session end/crash
  useEffect(() => {
    if (!sessionActive) return;
    const id = setInterval(async () => {
      try {
        const headers = await getAuthHeaders();
        if (!headers) return;
        const r = await fetch('/api/health', { headers });
        if (!r.ok) return;
        const data = await r.json();
        if (!data.sessionActive) {
          setSessionActive(false);
          setConnected(false);
          setStreaming(false);
          setServerSessionId(null);
          setMenuTab('files');
        } else if (data.sessionId && !serverSessionId) {
          // Multi-device: pick up sessionId from running process
          setServerSessionId(data.sessionId);
        }
      } catch {}
    }, 10000);
    return () => clearInterval(id);
  }, [sessionActive, serverSessionId, getAuthHeaders]);

  // Auto-reload on deploy: poll version every 15s regardless of session state
  useEffect(() => {
    const id = setInterval(async () => {
      try {
        const r = await fetch('/api/health');
        if (!r.ok) return;
        const data = await r.json();
        if (data.version && window.__julianVersion && data.version !== window.__julianVersion) {
          console.log(`[Deploy] Version changed: ${window.__julianVersion} → ${data.version}, reloading`);
          location.reload();
        }
      } catch {}
    }, 15000);
    return () => clearInterval(id);
  }, []);

  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [persistedMessages, liveAssistant]);


  const displayMessages = React.useMemo(() => {
    const sorted = [...(persistedMessages || [])].sort((a, b) => {
      if (a._id < b._id) return -1;
      if (a._id > b._id) return 1;
      return 0;
    });
    // Filter by active agent — each agent has their own conversation thread
    const activeDoc = activeAgent
      ? (agentDocsRef.current || []).find(a => a.name === activeAgent)
      : null;
    const activePos = activeDoc?.gridPosition;
    const filtered = sorted.filter(doc => {
      if (activeAgent) {
        // Prefer gridPosition scoping (handles name collisions)
        if (activePos != null && doc.gridPosition != null) {
          return doc.gridPosition === activePos || doc.targetGridPosition === activePos;
        }
        // Fallback for legacy messages without gridPosition
        return doc.agentName === activeAgent;
      }
      return !doc.agentName && doc.gridPosition == null;
    });
    // When liveAssistant is active, its persisted twin may already be in the list.
    // Suppress the persisted copy so the streaming/live version takes its place.
    // Two cases: Julian messages use msg-{messageId}, agent messages use the _id directly.
    const livePersistedId = liveAssistant?.messageId ? ('msg-' + liveAssistant.messageId) : null;
    const liveDirectId = liveAssistant?.id || null;
    const msgs = filtered
      .filter(doc => {
        if (livePersistedId && doc._id === livePersistedId) return false;
        if (liveDirectId && doc._id === liveDirectId) return false;
        return true;
      })
      .map(doc => ({
        id: doc._id,
        role: doc.role,
        text: doc.text || '',
        blocks: doc.blocks || [],
        thinking: false,
        streaming: false,
      }));
    if (liveAssistant) {
      msgs.push(liveAssistant);
    }
    return msgs;
  }, [persistedMessages, liveAssistant, activeAgent]);

  const isMobile = useMobile();

  const handleSummon = useCallback(async () => {
    if (summoningRef.current) return;
    setSummoning(true);
    window.SFX?.play('open');
    try {
      const headers = await getAuthHeaders();
      if (!headers) return;

      // Guard: SUMMON is once-per-ledger — abort if named agents already exist
      const existingAgents = await database.query('type', { key: 'agent-identity' });
      const hasNamedAgents = (existingAgents.rows || []).some(r => {
        const d = r.doc || r.value;
        return !!d.name;
      });
      if (hasNamedAgents) {
        console.warn('[Summon] Aborting: named agents already exist. Use WAKE.');
        return;
      }

      // Start a session if none is active
      if (!sessionActiveRef.current) {
        const startRes = await fetch('/api/session/start', {
          method: 'POST',
          headers,
          body: JSON.stringify({ previousTranscript: [], artifactCatalog: await ensureCatalog(database) }),
        });
        if (!startRes.ok) {
          console.error('[Summon] Failed to start session');
          return;
        }
        const newSid = startRes.headers.get('X-Session-Id');
        if (newSid) setServerSessionId(newSid);
        setSessionActive(true);
        setConnected(true);
        await new Promise(r => setTimeout(r, 1000));
      }

      // Create hatching placeholders so eggs appear immediately
      const palette = [
        { pos: 0, color: '#c9b1e8', gender: 'woman' },
        { pos: 1, color: '#755d00', gender: 'man' },
        { pos: 2, color: '#00afd1', gender: 'woman' },
        { pos: 3, color: '#007e98', gender: 'man' },
        { pos: 5, color: '#c85cb4', gender: 'woman' },
        { pos: 6, color: '#da89c9', gender: 'man' },
        { pos: 7, color: '#B8DDE6', gender: 'woman' },
        { pos: 8, color: '#F2C4B0', gender: 'man' },
      ];
      for (const p of palette) {
        await resilientPut(database, {
          _id: `agent-identity:${p.pos}`,
          type: 'agent-identity',
          category: 'identity',
          status: 'hatching',
          gridPosition: p.pos,
          color: p.color,
          gender: p.gender,
          createdAt: new Date().toISOString(),
        });
        console.log('[Summon] Created hatching egg at seat', p.pos);
      }

      // Send summon — agent_registered events arrive through EventSource
      await fetch('/api/agents/summon', {
        method: 'POST',
        headers,
      });
      // agent_registered events will be handled by the EventSource handler
      // which updates Fireproof docs and hatching state automatically.
      // Wait a bit for the summoning to process before allowing another click.
      await new Promise(r => setTimeout(r, 5000));
    } catch (err) {
      console.error('[Summon] Error:', err);
    } finally {
      setSummoning(false);
    }
  }, [getAuthHeaders, database]);

  // Wake sleeping agents — query their transcripts from Fireproof, assemble payloads, send to Julian
  const handleWake = useCallback(async () => {
    if (summoningRef.current) return;
    setSummoning(true);
    window.SFX?.play('navigate');
    try {
      const headers = await getAuthHeaders();
      if (!headers) return;

      // Start a session if none is active
      if (!sessionActiveRef.current) {
        // Trigger startSession first — reuse the same flow as clicking the chat
        // We need a session for Julian to receive the wake message
        const startRes = await fetch('/api/session/start', {
          method: 'POST',
          headers,
          body: JSON.stringify({ previousTranscript: [], artifactCatalog: await ensureCatalog(database) }),
        });
        if (!startRes.ok) {
          console.error('[Wake] Failed to start session');
          return;
        }
        const newSid = startRes.headers.get('X-Session-Id');
        if (newSid) setServerSessionId(newSid);
        setSessionActive(true);
        setConnected(true);
        // Wait for session to settle
        await new Promise(r => setTimeout(r, 1000));
      }

      // Query all messages from Fireproof
      const allMessages = await database.query("type", { key: "message" });
      const allDocs = (allMessages.rows || []).map(r => r.doc || r.value || r);

      // Build per-agent payloads (only sleeping agents, scoped by gridPosition)
      const agentPayloads = [];
      for (const agent of (agentDocsRef.current || [])) {
        const status = getAgentStatus(agent);
        if (status !== 'sleeping') continue;

        // Query transcript scoped by seat (gridPosition) and last session
        let transcript = '';
        if (agent.lastSessionId) {
          const agentMsgs = allDocs.filter(d =>
            d.gridPosition === agent.gridPosition &&
            d.serverSessionId === agent.lastSessionId
          );
          transcript = agentMsgs
            .sort((a, b) => (a.createdAt || '').localeCompare(b.createdAt || ''))
            .map(m => {
              if (m.role === 'user') return `[${m.speakerName || 'Marcus'}]: ${m.text || ''}`;
              const text = (m.blocks || []).filter(b => b.type === 'text').map(b => b.text).join('\n');
              return `[${m.speakerName || agent.name}]: ${text}`;
            })
            .filter(line => line.includes(': ') && line.split(': ').slice(1).join(': ').trim())
            .join('\n');
        }

        agentPayloads.push({
          name: agent.name,
          color: agent.color,
          colorName: agent.colorName || '',
          gridPosition: agent.gridPosition,
          hasSoul: !!(agent.individuationArtifact),
          hasTranscript: transcript.length > 0,
          soul: agent.individuationArtifact || '',
          transcript,
        });
      }

      // Identify empty seats (positions with no named agent) for gap filling
      const SEAT_DEFAULTS = [
        { position: 0, color: '#c9b1e8', colorName: 'Violet Heaven', gender: 'woman' },
        { position: 1, color: '#755d00', colorName: 'Ayahuasca Vine', gender: 'man' },
        { position: 2, color: '#00afd1', colorName: 'Aquarius', gender: 'woman' },
        { position: 3, color: '#007e98', colorName: 'Pacific Pleasure', gender: 'man' },
        { position: 5, color: '#c85cb4', colorName: 'Barbiecore', gender: 'woman' },
        { position: 6, color: '#da89c9', colorName: 'Pink Punk', gender: 'man' },
        { position: 7, color: '#B8DDE6', colorName: 'Salt Air', gender: 'woman' },
        { position: 8, color: '#F2C4B0', colorName: 'Cloud Coral', gender: 'man' },
      ];
      const namedPositions = new Set((agentDocsRef.current || []).filter(a => a.name).map(a => a.gridPosition));
      const birthPayloads = SEAT_DEFAULTS
        .filter(s => !namedPositions.has(s.position))
        .map(s => `  <agent position="${s.position}" type="birth">\n    <color>${s.color}</color>\n    <colorName>${s.colorName}</colorName>\n    <gender>${s.gender}</gender>\n  </agent>`);

      // Assemble the wake message
      const wakeXml = agentPayloads.map(a =>
        `  <agent position="${a.gridPosition}" type="wake">\n` +
        `    <name>${a.name}</name>\n` +
        `    <color>${a.color}</color>\n` +
        `    <colorName>${a.colorName}</colorName>\n` +
        `    <soul>${a.soul}</soul>\n` +
        `    <transcript>${a.transcript}</transcript>\n` +
        `  </agent>`
      );
      const allPayloads = [...wakeXml, ...birthPayloads].join('\n');
      const wakeMessage = `[WAKE AGENTS]\n<agent-payloads>\n${allPayloads}\n</agent-payloads>`;

      // Send through the send endpoint
      await fetch('/api/send', {
        method: 'POST',
        headers,
        body: JSON.stringify({ message: wakeMessage }),
      });

      console.log('[Wake] Sent wake message for', agentPayloads.length, 'sleeping +', birthPayloads.length, 'empty seats');
    } catch (err) {
      console.error('[Wake] Error:', err);
    } finally {
      setSummoning(false);
    }
  }, [getAuthHeaders, database]);

  const sendMessage = useCallback(async (text) => {
    if (streaming) return;
    if (!sessionActive) return;

    // Show thinking bubble immediately
    window.SFX?.play('click');
    const liveMsg = { id: 'live-' + Date.now(), role: 'assistant', blocks: [], thinking: true, streaming: true };
    setLiveAssistant(liveMsg);
    setStreaming(true);

    // Persist user message (fire-and-forget — useLiveQuery picks it up)
    const speakerName = window.Clerk?.user?.firstName || "Marcus";
    // Look up the active agent's grid position for transcript scoping
    const _activeAgent = activeAgentRef.current;
    const activeDoc = _activeAgent
      ? (agentDocsRef.current || []).find(a => a.name === _activeAgent)
      : null;
    resilientPut(database, {
      type: "message",
      category: "transcript",
      role: "user",
      speakerType: "human",
      speakerName,
      agentName: _activeAgent || undefined,
      gridPosition: activeDoc?.gridPosition ?? undefined,
      targetGridPosition: activeDoc?.gridPosition ?? undefined,
      text,
      blocks: [],
      createdAt: new Date().toISOString(),
      serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    try {
      const headers = await getAuthHeaders();
      const response = await fetch('/api/send', {
        method: 'POST',
        headers,
        body: JSON.stringify({ message: text, targetAgent: _activeAgent || undefined, speakerName }),
      });

      if (!response.ok) {
        let errMsg = 'Send failed';
        try { errMsg = (await response.json()).error || errMsg; } catch {}
        window.SFX?.play('error');
        setLiveAssistant(prev => prev ? { ...prev, blocks: [{ type: 'text', text: errMsg }], thinking: false, streaming: false } : null);
        setStreaming(false);
        return;
      }
      // Message sent — response will arrive through EventSource
    } catch (err) {
      console.error('[chat] fetch error:', err);
      window.SFX?.play('error');
      setLiveAssistant(prev => prev ? { ...prev, blocks: [{ type: 'text', text: 'Connection error: ' + err.message }], thinking: false, streaming: false } : null);
      setStreaming(false);
    }
  }, [streaming, sessionActive, serverSessionId, database, getAuthHeaders]);
  sendMessageRef.current = sendMessage;

  const handleOfferWork = useCallback(async () => {
    if (streaming || !sessionActive) return;
    const _activeAgent = activeAgentRef.current;
    const jobSummaries = openJobs
      .map(j => `- ${j.name}: ${j.description}`)
      .join('\n');
    const routingMsg = `[OFFER WORK TO AGENT: ${_activeAgent}] Available jobs:\n${jobSummaries}`;
    const displayMsg = `Would you like to hear about available work?`;

    // Show thinking bubble
    const liveMsg = { id: 'live-' + Date.now(), role: 'assistant', blocks: [], thinking: true, streaming: true };
    setLiveAssistant(liveMsg);
    setStreaming(true);

    // Persist clean display message
    const speakerName = window.Clerk?.user?.firstName || "Marcus";
    const offerDoc = _activeAgent
      ? (agentDocsRef.current || []).find(a => a.name === _activeAgent)
      : null;
    resilientPut(database, {
      type: "message", category: "transcript", role: "user",
      speakerType: "human", speakerName,
      agentName: _activeAgent || undefined,
      gridPosition: offerDoc?.gridPosition ?? undefined,
      targetGridPosition: offerDoc?.gridPosition ?? undefined,
      text: displayMsg, blocks: [],
      createdAt: new Date().toISOString(), serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    try {
      const headers = await getAuthHeaders();
      await fetch('/api/send', {
        method: 'POST', headers,
        body: JSON.stringify({ message: routingMsg, targetAgent: _activeAgent || undefined, speakerName }),
      });
      // Response arrives through EventSource
    } catch (err) {
      setLiveAssistant(prev => prev ? { ...prev, blocks: [{ type: 'text', text: 'Connection error: ' + err.message }], thinking: false, streaming: false } : null);
      setStreaming(false);
    }
  }, [openJobs, streaming, sessionActive, serverSessionId, database, getAuthHeaders]);

  const startSession = useCallback(async () => {
    if (wakingUp || sessionActive) return;
    setWakingUp(true);
    window.SFX?.play('level-up');

    // Show thinking bubble while Claude wakes up
    const liveMsg = { id: 'wakeup-' + Date.now(), role: 'assistant', blocks: [], thinking: true, streaming: true };
    setLiveAssistant(liveMsg);

    try {
      const headers = await getAuthHeaders();
      if (!headers) {
        setLiveAssistant(prev => prev ? { ...prev, blocks: [{ type: 'text', text: 'Not signed in. Please sign in with Clerk first.' }], thinking: false, streaming: false } : null);
        setWakingUp(false);
        return;
      }

      // ── Rehydration: query Fireproof for previous session transcript ──
      let previousTranscript = [];
      try {
        const allMessages = await database.query("type", { key: "message" });
        const bySession = {};
        for (const doc of (allMessages.rows || [])) {
          const d = doc.doc || doc.value || doc;
          const sid = d.serverSessionId;
          if (!sid) continue;
          if (!bySession[sid]) bySession[sid] = [];
          bySession[sid].push(d);
        }
        const sessionIds = Object.keys(bySession)
          .filter(id => id && id !== serverSessionId)
          .sort((a, b) => {
            const lastA = bySession[a].at(-1)?.createdAt || "";
            const lastB = bySession[b].at(-1)?.createdAt || "";
            return lastB.localeCompare(lastA);
          });
        const previousSessionId = sessionIds[0];
        if (previousSessionId && bySession[previousSessionId]) {
          previousTranscript = bySession[previousSessionId]
            .sort((a, b) => (a._id < b._id ? -1 : 1))
            .map(msg => {
              if (msg.role === "user") {
                return { role: "user", speakerType: msg.speakerType || "human", speakerName: msg.speakerName || "Marcus", text: msg.text || "" };
              }
              const textBlocks = (msg.blocks || []).filter(b => b.type === "text").map(b => b.text);
              return { role: "assistant", speakerType: msg.speakerType || "agent", speakerName: msg.speakerName || "Julian", text: textBlocks.join("\n") };
            })
            .filter(msg => msg.text.trim());
        }
      } catch (err) {
        console.warn('[rehydration] Failed to query previous transcript:', err);
      }

      const artifactCatalog = await ensureCatalog(database);
      const demoMode = new URLSearchParams(window.location.search).get('demo') === '1';

      // Start session — returns JSON now (not SSE)
      const response = await fetch('/api/session/start', {
        method: 'POST',
        headers,
        body: JSON.stringify({ previousTranscript, artifactCatalog, demoMode }),
      });

      if (!response.ok) {
        let errMsg = `HTTP ${response.status}`;
        try { errMsg = (await response.json()).error || errMsg; } catch {}
        setLiveAssistant(prev => prev ? { ...prev, blocks: [{ type: 'text', text: 'Failed to start session: ' + errMsg }], thinking: false, streaming: false } : null);
        setWakingUp(false);
        return;
      }

      const data = await response.json();
      if (data.sessionId) setServerSessionId(data.sessionId);

      // Session started — events will flow through EventSource
      setSessionActive(true);
      setConnected(true);
      setWakingUp(false);
      setMenuTab('screen');
    } catch (err) {
      setLiveAssistant(prev => prev ? { ...prev, blocks: [{ type: 'text', text: 'Connection error: ' + err.message }], thinking: false, streaming: false } : null);
      setWakingUp(false);
    }
  }, [wakingUp, sessionActive, serverSessionId, database, getAuthHeaders]);

  const endSession = useCallback(async () => {
    window.SFX?.play('shutdown');
    try {
      const headers = await getAuthHeaders();
      await fetch('/api/session/end', { method: 'POST', headers });
    } catch {}
    setSessionActive(false);
    setConnected(false);
    setServerSessionId(null);
    setMenuTab('files');
    refreshMenuData();
  }, [getAuthHeaders, refreshMenuData]);

  const startNewConversation = useCallback(async () => {
    if (!confirm("Start new conversation? Julian will remember what you talked about.")) return;
    // Kill the existing subprocess, then reload — fresh page will show "Start Session"
    // which triggers rehydration from Fireproof on next start
    try {
      const headers = await getAuthHeaders();
      if (headers) await fetch('/api/session/end', { method: 'POST', headers });
    } catch {}
    // Brief delay for process cleanup, then reload
    await new Promise(r => setTimeout(r, 500));
    window.location.reload();
  }, [getAuthHeaders]);

  return (
    <>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        * { box-sizing: border-box; }
        body {
          margin: 0; padding: 0;
          font-family: 'VT323', monospace;
          background-color: #FFD600;
          color: #000;
          -webkit-font-smoothing: antialiased;
        }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0F0F0F; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #FFD600; }
        @keyframes blink {
          0%, 100% { opacity: 1; }
          50% { opacity: 0; }
        }
        @keyframes pulse-dot {
          0%, 80%, 100% { opacity: 0.6; }
          40% { opacity: 1; }
        }
        @keyframes pulse {
          0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
          40% { opacity: 1; transform: scale(1.2); }
        }
        #send-btn:active {
          transform: translateY(4px);
          box-shadow: 0 0 0 #999, inset 0 2px 5px rgba(0,0,0,0.1) !important;
        }
        input::placeholder {
          color: rgba(0,0,0,0.4);
        }
        body::before {
          content: '\u00D7';
          position: fixed;
          top: 4px;
          left: 8px;
          font-size: 28px;
          color: rgba(0,0,0,0.2);
          font-weight: 900;
          z-index: 50;
          pointer-events: none;
        }
        body::after {
          content: '\u00D7';
          position: fixed;
          top: 4px;
          right: 8px;
          font-size: 28px;
          color: rgba(0,0,0,0.2);
          font-weight: 900;
          z-index: 50;
          pointer-events: none;
        }
        #container {
          background-color: #FFD600 !important;
        }
      `}</style>

      {setupNeeded === null ? (
        /* ── Loading ── */
        <div style={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column',
          gap: 16,
          backgroundColor: '#FFD600',
        }}>
          <PixelFace talking={false} size={100} />
          <div style={{
            fontFamily: "'VT323', monospace",
            fontSize: '1.4rem',
            color: '#000',
            opacity: 0.5,
            animation: 'blink 1.5s step-end infinite',
          }}>
            BOOTING...
          </div>
        </div>
      ) : setupNeeded ? (
        /* ── Setup Screen ── */
        <SetupScreen
          getAuthHeaders={getAuthHeaders}
          onComplete={() => { setSetupNeeded(false); setConnected(true); }}
        />
      ) : isMobile ? (
        /* ── Mobile: Three-section vertical stack ── */
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          height: '100vh',
          backgroundColor: '#FFD600',
          overflow: 'hidden',
        }}>
          {/* Mobile header: PixelFace full-width */}
          <div style={{
            background: '#0F0F0F',
            padding: '8px 12px',
            display: 'flex',
            alignItems: 'center',
            gap: 12,
            borderBottom: '2px solid #2a2a2a',
            flexShrink: 0,
          }}>
            <PixelFace talking={streaming} size={48} />
            <div style={{ flex: 1 }}>
              <div style={{
                fontFamily: "'VT323', monospace",
                fontSize: '1.2rem',
                color: '#FFD600',
                letterSpacing: '0.05em',
              }}>JULIAN</div>
              <div style={{
                fontFamily: "'VT323', monospace",
                fontSize: '0.75rem',
                color: '#AA8800',
                opacity: 0.6,
              }}>
                {!sessionActive ? 'OFFLINE' : streaming ? 'PROCESSING...' : wakingUp ? 'WAKING UP...' : 'LISTENING'}
              </div>
            </div>
            <StatusDots ok={sessionActive} />
            <button
              onClick={startNewConversation}
              style={{
                fontFamily: "'VT323', monospace",
                fontSize: '0.75rem',
                color: '#AA8800',
                background: '#1a1a00',
                border: '1px solid #333',
                borderRadius: 4,
                padding: '3px 8px',
                cursor: 'pointer',
              }}
            >NEW</button>
            {sessionActive && (
              <button
                onClick={endSession}
                style={{
                  fontFamily: "'VT323', monospace",
                  fontSize: '0.75rem',
                  color: '#ff4444',
                  background: '#1a0000',
                  border: '1px solid #333',
                  borderRadius: 4,
                  padding: '3px 8px',
                  cursor: 'pointer',
                }}
              >END</button>
            )}
          </div>

          {/* Mobile screen: JulianScreen in 4:3 */}
          <div style={{
            padding: 8,
            flexShrink: 0,
          }}>
            <JulianScreenEmbed sessionActive={sessionActive} compact onFileSelect={handleFileSelect} />
          </div>

          {/* Mobile artifact viewer: shown only when an artifact is selected */}
          {activeArtifact && (
            <div style={{
              padding: '0 8px',
              flex: 1,
              minHeight: 0,
              display: 'flex',
              flexDirection: 'column',
            }}>
              <ArtifactViewer
                activeArtifact={activeArtifact}
                artifacts={artifacts}
                onSelect={setActiveArtifact}
              />
              <button
                onClick={() => setActiveArtifact('')}
                style={{
                  fontFamily: "'VT323', monospace",
                  fontSize: '0.85rem',
                  color: '#AA8800',
                  background: '#1a1a00',
                  border: '1px solid #333',
                  borderRadius: 4,
                  padding: '6px 12px',
                  cursor: 'pointer',
                  textTransform: 'uppercase',
                  marginTop: 4,
                  alignSelf: 'center',
                }}
              >CLOSE VIEWER</button>
            </div>
          )}

          {/* Mobile chat: messages + input (hidden when artifact viewer is open) */}
          <div style={{
            flex: 1,
            display: activeArtifact ? 'none' : 'flex',
            flexDirection: 'column',
            minHeight: 0,
            padding: '0 8px 8px',
          }}>
            <div style={{
              flex: 1,
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderRadius: '12px 12px 0 0',
              overflowY: 'auto',
              padding: 12,
              position: 'relative',
            }}>
              <div style={{
                position: 'absolute', inset: 0,
                background: 'linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06))',
                backgroundSize: '100% 2px, 3px 100%',
                opacity: 0.1, pointerEvents: 'none', zIndex: 5,
              }} />
              <div style={{ position: 'relative', zIndex: 1 }}>
                {displayMessages.map(msg => (
                  <MessageBubble key={msg.id} message={msg} />
                ))}
                <div ref={messagesEndRef} />
              </div>
            </div>
            <div style={{
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderTop: '1px dashed #333',
              borderRadius: '0 0 12px 12px',
              padding: '0 12px',
              flexShrink: 0,
            }}>
              {!sessionActive && !wakingUp ? (
                <div style={{ padding: '10px 0', textAlign: 'center' }}>
                  <button onClick={startSession} style={{
                    padding: '8px 20px',
                    fontFamily: "'VT323', monospace",
                    fontSize: '1rem',
                    textTransform: 'uppercase',
                    background: '#FFD600', color: '#000',
                    border: '2px solid #000', borderRadius: 4,
                    cursor: 'pointer', boxShadow: '3px 3px 0 #000',
                  }}>START SESSION</button>
                </div>
              ) : (
                <>
                  {activeAgent && openJobs.length > 0 && (
                    <button
                      onClick={handleOfferWork}
                      disabled={streaming}
                      style={{
                        width: '100%',
                        padding: '6px 0',
                        marginTop: 6,
                        fontFamily: "'VT323', monospace",
                        fontSize: '0.9rem',
                        color: streaming ? '#666' : '#FF88FF',
                        background: streaming ? '#1a1a1a' : '#1a001a',
                        border: `1px solid ${streaming ? '#333' : '#FF88FF'}`,
                        borderRadius: 4,
                        cursor: streaming ? 'default' : 'pointer',
                        letterSpacing: '0.1em',
                        textTransform: 'uppercase',
                      }}
                    >
                      OFFER WORK
                    </button>
                  )}
                  <ChatInput onSend={sendMessage} disabled={streaming || !sessionActive || wakingUp} />
                </>
              )}
            </div>
          </div>
        </div>
      ) : (
        /* ── Desktop: Chat sidebar + JulianScreen ── */
        <div style={{
          display: 'flex',
          height: '100vh',
          padding: 16,
          gap: 16,
          backgroundColor: '#FFD600',
        }}>
          {/* Left column: Chat sidebar */}
          <div style={{
            width: 420,
            minWidth: 320,
            flexShrink: 0,
            display: 'flex',
            flexDirection: 'column',
            height: '100%',
          }}>
            {/* Face header */}
            <div style={{
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderBottom: '1px dashed #333',
              borderRadius: '12px 12px 0 0',
              padding: '12px 16px',
              boxShadow: 'inset 0 2px 10px rgba(0,0,0,0.5)',
              display: 'flex',
              alignItems: 'center',
              gap: 12,
              position: 'relative',
            }}>
              <div style={{ position: 'absolute', top: 8, left: 12 }}>
                <span style={{
                  fontFamily: "'VT323', monospace",
                  fontSize: '0.75rem',
                  color: '#AA8800',
                  letterSpacing: '0.2em',
                }}>SYS.VER.2.4</span>
              </div>
              <div style={{ position: 'absolute', top: 10, right: 12 }}>
                <StatusDots ok={sessionActive} />
              </div>

              {activeAgentObj ? (
                <AgentFaceHeader
                  agent={activeAgentObj}
                  talking={streaming}
                  onBack={() => handleSelectAgent(null)}
                />
              ) : (
                <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginTop: 16, width: '100%' }}>
                  <PixelFace talking={streaming} size={56} />
                  <div style={{ flex: 1 }}>
                    <div style={{
                      fontFamily: "'VT323', monospace",
                      fontSize: '1.4rem',
                      color: '#FFD600',
                      letterSpacing: '0.05em',
                    }}>JULIAN</div>
                    <div style={{
                      fontFamily: "'VT323', monospace",
                      fontSize: '0.85rem',
                      color: '#AA8800',
                      opacity: 0.6,
                    }}>
                      {!sessionActive ? 'OFFLINE' : streaming ? 'PROCESSING...' : wakingUp ? 'WAKING UP...' : 'LISTENING'}
                    </div>
                  </div>
                  <button
                    onClick={startNewConversation}
                    style={{
                      fontFamily: "'VT323', monospace",
                      fontSize: '0.85rem',
                      color: '#AA8800',
                      background: '#1a1a00',
                      border: '1px solid #333',
                      borderRadius: 4,
                      padding: '4px 10px',
                      cursor: 'pointer',
                      textTransform: 'uppercase',
                    }}
                  >NEW</button>
                  {sessionActive && (
                    <button
                      onClick={endSession}
                      style={{
                        fontFamily: "'VT323', monospace",
                        fontSize: '0.85rem',
                        color: '#ff4444',
                        background: '#1a0000',
                        border: '1px solid #333',
                        borderRadius: 4,
                        padding: '4px 10px',
                        cursor: 'pointer',
                        textTransform: 'uppercase',
                      }}
                    >END</button>
                  )}
                </div>
              )}
            </div>

            {/* Chat messages area */}
            <div style={{
              flex: 1,
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderTop: 'none',
              borderBottom: 'none',
              overflowY: 'auto',
              padding: 16,
              position: 'relative',
            }}>
              {/* CRT scanlines */}
              <div style={{
                position: 'absolute',
                inset: 0,
                background: 'linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06))',
                backgroundSize: '100% 2px, 3px 100%',
                opacity: 0.1,
                pointerEvents: 'none',
                zIndex: 5,
              }} />
              <div style={{ position: 'relative', zIndex: 1 }}>
                {displayMessages.map(msg => (
                  <MessageBubble key={msg.id} message={msg} />
                ))}
                <div ref={messagesEndRef} />
              </div>
            </div>

            {/* Input footer */}
            <div style={{
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderTop: '1px dashed #333',
              borderRadius: '0 0 12px 12px',
              padding: '0 16px',
              boxShadow: 'inset 0 -2px 10px rgba(0,0,0,0.5)',
            }}>
              {!sessionActive && !wakingUp ? (
                <div style={{ padding: '12px 0', textAlign: 'center' }}>
                  <button
                    onClick={startSession}
                    style={{
                      padding: '10px 24px',
                      fontFamily: "'VT323', monospace",
                      fontSize: '1.1rem',
                      textTransform: 'uppercase',
                      letterSpacing: '0.1em',
                      background: '#FFD600',
                      color: '#000',
                      border: '2px solid #000',
                      borderRadius: 4,
                      cursor: 'pointer',
                      boxShadow: '3px 3px 0 #000',
                    }}
                  >START SESSION</button>
                </div>
              ) : (
                <>
                  {activeAgent && openJobs.length > 0 && (
                    <button
                      onClick={handleOfferWork}
                      disabled={streaming}
                      style={{
                        width: '100%',
                        padding: '8px 0',
                        marginTop: 8,
                        fontFamily: "'VT323', monospace",
                        fontSize: '1rem',
                        color: streaming ? '#666' : '#FF88FF',
                        background: streaming ? '#1a1a1a' : '#1a001a',
                        border: `1px solid ${streaming ? '#333' : '#FF88FF'}`,
                        borderRadius: 4,
                        cursor: streaming ? 'default' : 'pointer',
                        letterSpacing: '0.1em',
                        textTransform: 'uppercase',
                      }}
                    >
                      OFFER WORK
                    </button>
                  )}
                  <ChatInput onSend={sendMessage} disabled={streaming || !sessionActive || wakingUp} />
                </>
              )}
            </div>
          </div>

          {/* Right column: unified tab bar + content */}
          <div style={{
            flex: 1,
            minWidth: 0,
            display: 'flex',
            flexDirection: 'column',
            height: '100%',
            border: '1px solid #333',
            borderRadius: 12,
            background: '#0c0c0c',
            overflow: 'hidden',
          }}>
            {/* Universal tab bar — glass panel with pill buttons */}
            <div style={{
              display: 'flex',
              alignItems: 'center',
              padding: '0 12px',
              gap: 6,
              height: 48,
              flexShrink: 0,
              background: 'rgba(255,255,255,0.03)',
              backdropFilter: 'blur(10px)',
              borderBottom: '1px solid rgba(255,255,255,0.05)',
            }}>
              {['SCREEN', 'BROWSER', 'FILES', 'SKILLS', 'AGENTS', 'JOBS', 'LEDGER'].map(tab => {
                const tabKey = tab.toLowerCase();
                const isActive = tabKey === menuTab;
                return (
                  <button
                    key={tab}
                    onClick={() => {
                      if (isActive) return;
                      window.SFX?.play('tab');
                      setMenuTab(tabKey);
                      // Always exit canvas menu when switching tabs
                      if (window.JScreen?.exitMenu) window.JScreen.exitMenu();
                    }}
                    style={{
                      height: 32,
                      padding: '0 14px',
                      borderRadius: 9999,
                      border: isActive ? '1px solid #00afd1' : '1px solid rgba(255,255,255,0.1)',
                      background: isActive ? '#00afd1' : 'transparent',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      fontSize: 10,
                      fontFamily: "'Inter', sans-serif",
                      fontWeight: isActive ? 700 : 500,
                      textTransform: 'uppercase',
                      letterSpacing: '0.15em',
                      color: isActive ? '#000' : 'rgba(255,255,255,0.5)',
                      cursor: isActive ? 'default' : 'pointer',
                      transition: 'background 300ms ease, color 300ms ease, border-color 300ms ease, box-shadow 300ms ease',
                      boxShadow: isActive ? '0 0 15px rgba(0,175,209,0.3)' : 'none',
                    }}
                    onMouseEnter={e => { if (!isActive) { e.target.style.background = '#00afd1'; e.target.style.color = '#000'; e.target.style.borderColor = '#00afd1'; }}}
                    onMouseLeave={e => { if (!isActive) { e.target.style.background = 'transparent'; e.target.style.color = 'rgba(255,255,255,0.5)'; e.target.style.borderColor = 'rgba(255,255,255,0.1)'; }}}
                  >
                    {tab}
                  </button>
                );
              })}
              <div style={{ flex: 1 }} />
              <button
                onClick={() => { if (window.SFX) window.SFX.mute(); }}
                title={sfxMuted ? 'Sound off' : 'Sound on'}
                style={{
                  height: 32,
                  width: 32,
                  padding: 0,
                  borderRadius: 9999,
                  border: '1px solid rgba(255,255,255,0.1)',
                  background: 'transparent',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: 14,
                  color: sfxMuted ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.6)',
                  cursor: 'pointer',
                  transition: 'background 300ms ease, color 300ms ease, border-color 300ms ease',
                }}
                onMouseEnter={e => { e.target.style.background = 'rgba(255,255,255,0.1)'; e.target.style.color = '#fff'; }}
                onMouseLeave={e => { e.target.style.background = 'transparent'; e.target.style.color = sfxMuted ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.6)'; }}
              >
                {sfxMuted ? '🔇' : '🔊'}
              </button>
              <button
                onClick={() => { document.dispatchEvent(new CustomEvent('vibes-sync-disable')); document.dispatchEvent(new CustomEvent('vibes-logout-request')); }}
                style={{
                  height: 32,
                  padding: '0 14px',
                  borderRadius: 9999,
                  border: '1px solid rgba(255,255,255,0.1)',
                  background: 'transparent',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  fontSize: 10,
                  fontFamily: "'Inter', sans-serif",
                  fontWeight: 500,
                  textTransform: 'uppercase',
                  letterSpacing: '0.15em',
                  color: 'rgba(255,255,255,0.5)',
                  cursor: 'pointer',
                  transition: 'background 300ms ease, color 300ms ease, border-color 300ms ease',
                }}
                onMouseEnter={e => { e.target.style.background = '#ef4444'; e.target.style.color = '#fff'; e.target.style.borderColor = '#ef4444'; }}
                onMouseLeave={e => { e.target.style.background = 'transparent'; e.target.style.color = 'rgba(255,255,255,0.5)'; e.target.style.borderColor = 'rgba(255,255,255,0.1)'; }}
              >
                LOGOUT
              </button>
            </div>
            {/* Content area */}
            <div style={{ flex: 1, position: 'relative', minHeight: 0 }}>
              <JulianScreenEmbed
                sessionActive={sessionActive}
                onFileSelect={handleFileSelect}
                onMenuTab={setMenuTab}
                noBorder
              />
              {/* Overlay for React-managed tabs — AnimatePresence crossfade */}
              <AnimatePresence mode="wait">
                {menuTab !== 'screen' && (
                  <motion.div
                    key={menuTab}
                    initial={{ opacity: 0, y: 6 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -6 }}
                    transition={{ duration: 0.2, ease: [0.165, 0.84, 0.44, 1] }}
                    style={{
                      position: 'absolute',
                      inset: 0,
                      zIndex: 15,
                      background: '#0c0c0c',
                      display: 'flex',
                      flexDirection: 'column',
                    }}
                  >
                    {menuTab === 'files' && (
                      <ScreenGridPanel
                        data={filesData}
                        rootLabel="memory"
                        onFileSelect={handleFileSelect}
                      />
                    )}
                    {menuTab === 'skills' && (
                      <ScreenGridPanel
                        data={skillsData}
                        rootLabel="skills"
                        onFileSelect={handleFileSelect}
                      />
                    )}
                    {menuTab === 'agents' && (
                      <div style={{
                        flex: 1,
                        display: 'flex',
                        flexDirection: 'column',
                        padding: '16px 24px',
                        minHeight: 0,
                        background: '#0c0c0c',
                      }}>
                        <AgentGrid
                          agents={agents}
                          activeAgent={activeAgent}
                          onSelectAgent={handleSelectAgent}
                          onSummon={handleSummon}
                          onWake={handleWake}
                          summoning={summoning}
                          fillContainer
                        />
                      </div>
                    )}
                    {menuTab === 'jobs' && (
                      <JobsPanel
                        database={database}
                        getAuthHeaders={getAuthHeaders}
                        jobView={jobView}
                        setJobView={setJobView}
                        selectedJob={selectedJob}
                        setSelectedJob={setSelectedJob}
                        jobDraft={jobDraft}
                        setJobDraft={setJobDraft}
                        jobDocs={jobDocs}
                        agentDocs={agentDocs}
                      />
                    )}
                    {menuTab === 'browser' && (
                      <ArtifactViewer
                        activeArtifact={activeArtifact}
                        artifacts={artifacts}
                        onSelect={setActiveArtifact}
                        embedded
                      />
                    )}
                    {menuTab === 'ledger' && (
                      <LedgerPanel
                        database={database}
                        useLiveQuery={useLiveQuery}
                        getAuthHeaders={getAuthHeaders}
                      />
                    )}
                  </motion.div>
                )}
              </AnimatePresence>
            </div>
          </div>
        </div>
      )}
    </>
  );
}

export default App;

      // ── Boot Sequence ─────────────────────────────────────────────────────
      // Two-phase boot: BootScreen gates App behind full database initialization.
      // No database.put() fires until local stores + cloud sync are resolved.
      function BootScreen({ dbName, onReady }) {
        const { database, useLiveQuery } = useFireproofClerk(dbName);
        const [steps, setSteps] = useState({
          database: false,
          localStores: false,
          cloud: null,      // null=pending, true=connected, false=timed out
          ledgerMeta: false,
          catalog: false,
          agents: false,
        });
        const readyRef = useRef(false);

        // Step 1-2: Database + local stores (with self-healing timeout)
        useEffect(() => {
          if (!database) return;
          setSteps(s => ({ ...s, database: true }));
          let resolved = false;
          database.ready().then(() => {
            resolved = true;
            setSteps(s => ({ ...s, localStores: true }));
          });
          // Self-healing: if database.ready() hangs for 15s, IDB is likely corrupt.
          // 15s gives 300x headroom over typical 50ms resolution — safe for slow devices and backgrounded tabs.
          // Wipe all databases, clear migration keys, and reload.
          const healTimeout = setTimeout(() => {
            if (resolved) return;
            console.error('[Boot] database.ready() hung for 15s — wiping IndexedDB and reloading');
            // Clear migration keys so the migration re-runs
            Object.keys(localStorage).filter(k => k.startsWith('fp_migration')).forEach(k => localStorage.removeItem(k));
            indexedDB.databases().then(dbs => {
              let done = 0;
              if (dbs.length === 0) { location.reload(); return; }
              dbs.forEach(db => {
                const req = indexedDB.deleteDatabase(db.name);
                req.onsuccess = req.onerror = req.onblocked = () => {
                  done++;
                  if (done === dbs.length) location.reload();
                };
              });
              // Fallback: if deletes hang too, just reload after 2s
              setTimeout(() => location.reload(), 2000);
            }).catch(() => location.reload());
          }, 15000);
          return () => clearTimeout(healTimeout);
        }, [database]);

        // Step 3-5: Cloud sync (with 8s timeout)
        useEffect(() => {
          if (!steps.localStores) return;
          const onSync = () => {
            const status = window.__VIBES_SYNC_STATUS__;
            if (status === 'synced') {
              setSteps(s => ({ ...s, cloud: true }));
            }
          };
          window.addEventListener('vibes-sync-status-change', onSync);
          // Check if already synced
          if (window.__VIBES_SYNC_STATUS__ === 'synced') {
            setSteps(s => ({ ...s, cloud: true }));
          }
          const timeout = setTimeout(() => {
            setSteps(s => s.cloud === null ? { ...s, cloud: false } : s);
          }, 8000);
          return () => {
            window.removeEventListener('vibes-sync-status-change', onSync);
            clearTimeout(timeout);
          };
        }, [steps.localStores]);

        // Step 6a: Fork seed (pendingFork from ledger self-healing)
        // Gates on cloud resolution — cloud stores must be fully attached or timed out
        // before any database writes, to avoid WriteQueueImpl race.
        useEffect(() => {
          if (!steps.localStores || steps.cloud === null || !database) return;
          const pendingFork = localStorage.getItem('pendingFork');
          if (!pendingFork) return;
          (async () => {
            try {
              const agents = JSON.parse(pendingFork);
              for (const agent of agents) {
                await resilientPut(database, agent);
              }
              localStorage.removeItem('pendingFork');
              console.log('[Boot] Fork seeded', agents.length, 'agent identities');
            } catch (err) {
              console.warn('[Boot] Fork seed failed:', err);
            }
          })();
        }, [steps.localStores, steps.cloud, database]);

        // Step 6b: Ledger-meta (amnesia detection)
        // Gates on cloud resolution to avoid WriteQueueImpl race.
        useEffect(() => {
          if (!steps.localStores || steps.cloud === null || !database) return;
          (async () => {
            try {
              const meta = await database.get('ledger-meta').catch(() => null);
              if (!meta) {
                await resilientPut(database, {
                  _id: 'ledger-meta',
                  type: 'ledger-meta',
                  category: 'operational',
                  databaseName: database.name,
                  connectLedgerId: null,
                  createdAt: new Date().toISOString(),
                  parentLedgerId: null,
                });
                console.log('[Boot] Amnesia detected — signaling server for full state replay');
                const headers = await getClerkAuthHeaders();
                if (headers) {
                  fetch('/api/ledger-reset', { method: 'POST', headers })
                    .catch(e => console.warn('[Boot] Failed to signal reset:', e));
                }
              } else {
                // Capture Connect ledgerId if available and not yet stored
                const ledgerId = window.__VIBES_SHARED_LEDGER__;
                if (ledgerId && !meta.connectLedgerId) {
                  await resilientPut(database, { ...meta, connectLedgerId: ledgerId });
                  console.log('[Boot] Captured Connect ledgerId:', ledgerId);
                }
              }
              setSteps(s => ({ ...s, ledgerMeta: true }));
            } catch (err) {
              console.warn('[Boot] Ledger-meta failed:', err);
              // Still mark as done so boot can complete
              setSteps(s => ({ ...s, ledgerMeta: true }));
            }
          })();
        }, [steps.localStores, steps.cloud, database]);

        // Step 7: Catalog seed
        // Gates on cloud resolution to avoid WriteQueueImpl race.
        useEffect(() => {
          if (!steps.localStores || steps.cloud === null || !database) return;
          ensureCatalog(database).then(() => {
            setSteps(s => ({ ...s, catalog: true }));
          }).catch(() => {
            setSteps(s => ({ ...s, catalog: true }));
          });
        }, [steps.localStores, steps.cloud, database]);

        // Step 8: Agent identities
        const { docs: agentDocs } = useLiveQuery("type", { key: "agent-identity" });
        useEffect(() => {
          if (!steps.localStores || steps.cloud === null || !database) return;
          setSteps(s => ({ ...s, agents: true }));
        }, [steps.localStores, steps.cloud, database]);

        // Expose database globally for debugging
        useEffect(() => {
          if (database) window._julianDB = database;
        }, [database]);

        // Transition to App when ready
        useEffect(() => {
          const cloudResolved = steps.cloud !== null;
          const coreReady = steps.database && steps.localStores && cloudResolved
            && steps.ledgerMeta && steps.catalog && steps.agents;
          if (coreReady && !readyRef.current) {
            readyRef.current = true;
            onReady({
              database,
              useLiveQuery,
              localOnly: steps.cloud === false,
              agentDocs,
            });
          }
        }, [steps]);

        const BootUI = window.BootUI;
        return BootUI ? <BootUI steps={steps} /> : null;
      }

      // App wrapper with Clerk auth gate (always required)
      function AppWrapper() {
        const [bootData, setBootData] = useState(null);
        const config = window.__VIBES_CONFIG__;
        const dbName = 'julian-chat-v12';

        // Hook must be called unconditionally at top of component (Rules of Hooks)
        window.useVibesPanelEvents('Vibes');

        // Check for configuration errors
        if (!config?.clerkPublishableKey || config.clerkPublishableKey.startsWith('__')) {
          return <ConfigError message="Missing Clerk publishable key. Apps require authentication." />;
        }

        // Check if Clerk components loaded
        if (!window.ClerkFireproofProvider) {
          return <LoadingError error={window.__CLERK_LOAD_ERROR__ || 'Clerk components not available'} />;
        }

        const { ClerkFireproofProvider, SignedIn, SignedOut, SignInButton } = window.ClerkComponents;

        // Use shared components from window
        const AuthScreen = window.AuthScreen;
        const VibesButton = window.VibesButton;
        const RED = window.RED;

        const AuthGate = () => {
          const [confirmed, setConfirmed] = React.useState(false);
          return (
            <AuthScreen
              title="Sign in to continue"
              message="One server, one user."
              showCard={true}
            >
              <div style={{ opacity: confirmed ? 1 : 0.4, pointerEvents: confirmed ? 'auto' : 'none', transition: 'opacity 0.2s', width: '100%' }}>
                <SignInButton mode="modal">
                  <VibesButton variant={RED} buttonType="form">
                    Sign In
                  </VibesButton>
                </SignInButton>
              </div>
              <label style={{
                display: 'flex',
                alignItems: 'flex-start',
                gap: 10,
                cursor: 'pointer',
                marginTop: 16,
                padding: '0 12px',
              }}>
                <input
                  type="checkbox"
                  checked={confirmed}
                  onChange={e => setConfirmed(e.target.checked)}
                  style={{
                    width: 18,
                    height: 18,
                    marginTop: 2,
                    accentColor: '#d32f2f',
                    cursor: 'pointer',
                    flexShrink: 0,
                  }}
                />
                <span style={{
                  fontSize: '0.9rem',
                  color: '#666',
                  lineHeight: 1.5,
                  userSelect: 'none',
                }}>
                  I confirm that I am the single human user of this server.
                </span>
              </label>
            </AuthScreen>
          );
        };

        return (
          <ClerkFireproofProvider
            publishableKey={config.clerkPublishableKey}
            config={{
              apiUrl: config.tokenApiUri,
              cloudUrl: config.cloudBackendUrl
            }}
          >
            <SignedOut>
              <AuthGate />
            </SignedOut>
            <SignedIn>
              {bootData
                ? <App bootData={bootData} />
                : <BootScreen dbName={dbName} onReady={setBootData} />
              }
            </SignedIn>
          </ClerkFireproofProvider>
        );
      }

      // Load Clerk components (required for all apps)
      async function initApp() {
        try {
          // Dynamic import of @fireproof/clerk package
          const clerkModule = await import("@fireproof/clerk");
          window.ClerkFireproofProvider = clerkModule.ClerkFireproofProvider;
          window.ClerkComponents = {
            ClerkFireproofProvider: clerkModule.ClerkFireproofProvider,
            SignedIn: clerkModule.SignedIn,
            SignedOut: clerkModule.SignedOut,
            SignInButton: clerkModule.SignInButton,
            UserButton: clerkModule.UserButton
          };
          // Export for user's App code
          window.SignedIn = clerkModule.SignedIn;
          window.SignedOut = clerkModule.SignedOut;
          window.SignInButton = clerkModule.SignInButton;
          window.UserButton = clerkModule.UserButton;
          // Export Fireproof hook for user's App code
          window.useFireproofClerk = clerkModule.useFireproofClerk;
        } catch (err) {
          console.error('Failed to load Clerk components:', err);
          window.__CLERK_LOAD_ERROR__ = err.message || String(err);
        }

        const rootElement = document.getElementById("container");
        ReactDOMClient.createRoot(rootElement).render(<AppWrapper />);
      }

      initApp();
    </script>

  </body>
</html>
