<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Made on Vibes DIY</title>
    <link rel="icon" type="image/svg+xml" href="/assets/icons/favicon.svg" />
    <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png" />
    <link rel="icon" type="image/x-icon" href="/assets/icons/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-touch-icon.png" />
    <link rel="manifest" href="/assets/icons/site.webmanifest" />
    <meta name="theme-color" content="#FFD600" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Julian" />
    <script>globalThis.process = { env: { NODE_ENV: "production" } };</script>
    <script>
      // One-time IndexedDB migration: clear corrupted Fireproof CRDT state
      // caused by failed auth syncs (401 on /tokens/with-email).
      // Bump DB_VERSION to re-trigger if corruption recurs.
      (function() {
        var DB_VERSION = 3;
        var KEY = 'fp_migration_v' + DB_VERSION;
        if (localStorage.getItem(KEY)) return;
        var dbs = indexedDB.databases ? indexedDB.databases() : Promise.resolve([]);
        dbs.then(function(databases) {
          var fpDbs = databases.filter(function(db) {
            return db.name && db.name.indexOf('fireproof') !== -1;
          });
          if (fpDbs.length === 0) {
            localStorage.setItem(KEY, Date.now());
            return;
          }
          var deleted = 0;
          fpDbs.forEach(function(db) {
            var req = indexedDB.deleteDatabase(db.name);
            req.onsuccess = req.onerror = function() {
              deleted++;
              if (deleted === fpDbs.length) {
                localStorage.setItem(KEY, Date.now());
                location.reload();
              }
            };
          });
        }).catch(function() {
          localStorage.setItem(KEY, Date.now());
        });
      })();
    </script>
    <script src="https://unpkg.com/@babel/standalone@7.26.0/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- JulianScreen client modules (must load in order: renderer creates window.JScreen, others attach to it) -->
    <script src="/julianscreen/client/renderer.js"></script>
    <script src="/julianscreen/client/sprites.js"></script>
    <script src="/julianscreen/client/tiles.js"></script>
    <script src="/julianscreen/client/text.js"></script>
    <script src="/julianscreen/client/input.js"></script>
    <script src="/julianscreen/client/effects.js"></script>
    <script src="/julianscreen/client/menu.js"></script>
    <style>
      :root {
        /* Core colors */
        --vibes-black: #0f172a;
        --vibes-white: #ffffff;
        --vibes-near-black: #1a1a1a;
        --vibes-cream: #fffff0;

        /* Gray scale */
        --vibes-gray-lightest: #f1f5f9;
        --vibes-gray-ultralight: #f8fafc;
        --vibes-gray-mid: #555555;

        /* Menu colors */
        --vibes-menu-bg: #CCCDC8;
        --vibes-menu-grid: rgba(255, 255, 255, 0.5);

        /* Button variant colors */
        --vibes-variant-blue: #009ACE;
        --vibes-variant-red: #DA291C;
        --vibes-variant-yellow: #eab308;
        --vibes-variant-gray: #6b7280;

        /* Button styling */
        --vibes-button-bg: var(--vibes-cream);
        --vibes-button-text: var(--vibes-near-black);
        --vibes-button-border: var(--vibes-near-black);
        --vibes-button-icon-bg: #fff;
        --vibes-button-icon-fill: #2a2a2a;

        /* Dark-aware button variants (for components using ignoreDarkMode=false) */
        --vibes-button-bg-dark-aware: var(--vibes-cream);
        --vibes-button-text-dark-aware: var(--vibes-near-black);
        --vibes-button-border-dark-aware: var(--vibes-near-black);
        --vibes-button-icon-bg-dark-aware: var(--vibes-white);

        /* Card colors */
        --vibes-card-bg: var(--vibes-cream);
        --vibes-card-text: var(--vibes-near-black);
        --vibes-card-border: var(--vibes-near-black);

        /* Status colors */
        --vibes-green: #22c55e;
        --vibes-red-accent: #ef4444;
        --vibes-yellow-accent: #eab308;
        --vibes-shadow-color: rgba(0, 0, 0, 0.2);

        /* Text colors */
        --vibes-text-primary: var(--vibes-near-black);

        /* Landing page theming (customize these for brand) */
        --landing-accent: #0f172a;
        --landing-accent-hover: #1e293b;

        /* Admin dashboard theming */
        --admin-bg: oklch(0.97 0.01 250);
        --admin-card-bg: white;
        --admin-text: #0f172a;
        --admin-text-muted: #64748b;
        --admin-accent: oklch(0.6 0.2 145);
        --admin-border: #0f172a;
        --admin-shadow: #0f172a;
      }
      @media (prefers-color-scheme: dark) {
        :root {
          --vibes-button-bg-dark-aware: #2a2a2a;
          --vibes-button-text-dark-aware: var(--vibes-gray-ultralight);
          --vibes-button-border-dark-aware: var(--vibes-gray-mid);
          --vibes-button-icon-bg-dark-aware: #404040;
        }
      }

      /* Admin menu overrides - scoped to VibesPanel in HiddenMenuWrapper */
      #hidden-menu {
        /* Gray scale needed by components */
        --vibes-gray-lighter: #cccccc;
        --vibes-gray-pale: #e5e5e5;
        --vibes-gray-dark: #333333;

        /* Variant colors (fix yellow being red) */
        --vibes-variant-blue: #3b82f6;
        --vibes-variant-red: #ef4444;
        --vibes-variant-yellow: #eab308;

        /* Button styling */
        --vibes-button-bg: var(--vibes-cream);
        --vibes-button-text: var(--vibes-near-black);
        --vibes-button-border: var(--vibes-near-black);
        --vibes-button-icon-bg: #2a2a2a;
        --vibes-button-icon-fill: var(--vibes-white);

        /* Dark-aware variants (used when ignoreDarkMode=false) */
        --vibes-button-bg-dark-aware: var(--vibes-cream);
        --vibes-button-text-dark-aware: var(--vibes-near-black);
        --vibes-button-border-dark-aware: var(--vibes-near-black);
        --vibes-button-icon-bg-dark-aware: var(--vibes-white);

        /* Card styling */
        --vibes-card-bg: var(--vibes-gray-pale);
        --vibes-card-text: var(--vibes-near-black);
        --vibes-card-border: var(--vibes-near-black);

        /* Text */
        --vibes-text-primary: var(--vibes-gray-dark);

        /* Shadows */
        --vibes-shadow-color: var(--vibes-near-black);
      }

      @media (prefers-color-scheme: dark) {
        #hidden-menu {
          --vibes-button-bg-dark-aware: #2a2a2a;
          --vibes-button-text-dark-aware: var(--vibes-gray-ultralight);
          --vibes-button-border-dark-aware: var(--vibes-gray-mid);
          --vibes-button-icon-bg-dark-aware: #404040;
          --vibes-card-bg: var(--vibes-near-black);
          --vibes-card-text: var(--vibes-white);
          --vibes-card-border: var(--vibes-gray-mid);
        }
      }

      /* VibesSwitch toggle button - override app-level button styling */
      button[aria-controls="hidden-menu"] {
        background: transparent !important;
        background-color: transparent !important;
        padding: 0 !important;
        border: none !important;
      }

      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      }
      #container {
        width: 100%;
        height: 100vh;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/stable/react@19.2.4",
          "react/jsx-runtime": "https://esm.sh/stable/react@19.2.4/jsx-runtime",
          "react/jsx-dev-runtime": "https://esm.sh/stable/react@19.2.4/jsx-dev-runtime",
          "react-dom": "https://esm.sh/stable/react-dom@19.2.4",
          "react-dom/client": "https://esm.sh/stable/react-dom@19.2.4/client",
          "multiformats": "https://esm.sh/stable/multiformats@13.3.1",
          "multiformats/": "https://esm.sh/stable/multiformats@13.3.1/",
          "@ipld/dag-cbor": "https://esm.sh/stable/@ipld/dag-cbor@9.2.2?external=multiformats",
          "@ipld/dag-json": "https://esm.sh/stable/@ipld/dag-json@10.2.3?external=multiformats",
          "@clerk/clerk-react": "https://esm.sh/stable/@clerk/clerk-react@5.59.2?external=react,react-dom",
          "use-fireproof": "/bundles/fireproof-vibes-bridge.js",
          "@fireproof/clerk": "/bundles/fireproof-vibes-bridge.js"
        }
      }
    </script>
    <!-- Connect configuration - populated by assemble.js from .env -->
    <script>
      window.__VIBES_CONFIG__ = {
        tokenApiUri: "https://connect-share.exe.xyz/api/",
        cloudBackendUrl: "fpcloud://connect-share.exe.xyz?protocol=wss",
        // Must match VITE_CLERK_PUBLISHABLE_KEY in server/julian-bridge.service
        clerkPublishableKey: "pk_test_aW50ZXJuYWwtZGluZ28tMjguY2xlcmsuYWNjb3VudHMuZGV2JA"
      };
    </script>
    <!-- Load React globally for menu components -->
    <script type="module">
      import * as React from "react";
      window.React = React;
    </script>
    <!-- Vibes component library (auto-generated, rarely changes) -->
    <script type="text/babel" src="/vibes.jsx"></script>
    <!-- Chat UI components (PixelFace, MessageBubble, SetupScreen, etc.) -->
    <script type="text/babel" src="/chat.jsx"></script>
    <!-- App component + initialization -->
    <script type="text/babel" data-type="module">
      import ReactDOMClient from "react-dom/client";
      import React, { useState, useEffect, useRef, useCallback, useMemo } from "react";
      import { useFireproofClerk } from "use-fireproof";

      // Pull chat.jsx window exports into module scope
      const { ArtifactViewer, JulianScreenEmbed, SetupScreen, ChatInput,
              MessageBubble, ToolCallBlock, ThinkingDots, StatusDots,
              PixelFace, ConfigError, LoadingError,
              AgentGrid, AgentFaceHeader, EggHatch,
              hashNameToFaceVariant, AGENT_COLORS,
              JobsPanel } = window;

/* ── Artifact catalog ─────────────────────────────────────────────────────
 * Julian's memory catalog is a single XML document (catalog.xml) containing
 * all artifact metadata and stripped content. On first startSession, it's
 * fetched once and stored as a single Fireproof record — one write instead
 * of 28. The XML is static, generated at build time by scripts/build-catalog.js.
 *
 * To rebuild: bun scripts/build-catalog.js
 * ──────────────────────────────────────────────────────────────────────── */

// Parse catalog XML into metadata array for session start
function parseCatalogXML(xmlString) {
  const doc = new DOMParser().parseFromString(xmlString, "text/xml");
  return [...doc.querySelectorAll("artifact")].map(el => ({
    filename: el.getAttribute("filename"),
    dir: el.getAttribute("dir"),
    title: el.getAttribute("title"),
    category: el.getAttribute("category"),
    chapter: el.getAttribute("chapter"),
    description: el.getAttribute("description"),
  }));
}

// Ensure catalog record exists in Fireproof, fetch and store if missing
async function ensureCatalog(database) {
  try {
    const existing = await database.query("type", { key: "artifact-catalog" });
    if (existing.rows.length > 0) {
      const doc = existing.rows[0].doc || existing.rows[0].value;
      console.log("[catalog] Found existing catalog record");
      return parseCatalogXML(doc.content);
    }
  } catch (err) {
    console.warn("[catalog] Query failed, will fetch:", err);
  }

  try {
    const res = await fetch("/catalog.xml");
    if (!res.ok) throw new Error("HTTP " + res.status);
    const xml = await res.text();
    await database.put({ type: "artifact-catalog", content: xml, createdAt: new Date().toISOString() });
    console.log("[catalog] Fetched and stored catalog record");
    return parseCatalogXML(xml);
  } catch (err) {
    console.warn("[catalog] Failed to fetch catalog.xml:", err);
    return [];
  }
}

/* ── SSE stream reader ────────────────────────────────────────────────── */

async function streamSSEResponse(response, setLiveAssistant) {
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let sseBuffer = '';
  let finalBlocks = [];

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    sseBuffer += decoder.decode(value, { stream: true });
    const lines = sseBuffer.split('\n');
    sseBuffer = lines.pop() || '';

    for (const line of lines) {
      if (!line.startsWith('data: ')) continue;
      try {
        const data = JSON.parse(line.slice(6));
        if (data.type === 'done') continue;

        if (data.type === 'error') {
          finalBlocks = [{ type: 'text', text: 'Error: ' + (data.data?.message || 'Unknown error') }];
          setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
          continue;
        }

        const eventData = data.data;
        if (!eventData) continue;
        if (eventData.type === 'system') continue;

        if (eventData.type === 'assistant' && eventData.message?.content) {
          const blocks = eventData.message.content.map(block => {
            if (block.type === 'text') return { type: 'text', text: block.text };
            if (block.type === 'tool_use') {
              return { type: 'tool_use', name: block.name, input: block.input };
            }
            return block;
          });
          finalBlocks = blocks;
          setLiveAssistant(prev => prev ? { ...prev, blocks, thinking: false, streaming: true } : null);
        }

        if (eventData.type === 'result') {
          if (eventData.result && finalBlocks.length === 0) {
            finalBlocks = [{ type: 'text', text: eventData.result }];
          }
          setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
        }
      } catch (parseErr) {
        console.warn('[SSE] Failed to parse event:', parseErr, line);
      }
    }
  }

  return finalBlocks;
}

/* ── Main App ────────────────────────────────────────────────────────────── */

function App() {
  const { database, useLiveQuery } = useFireproofClerk("julian-chat-v2");

  useEffect(() => {
    window._julianDB = database;
  }, [database]);

  const { docs: persistedMessages } = useLiveQuery("type", { key: "message" });

  const [liveAssistant, setLiveAssistant] = useState(null);
  const [streaming, setStreaming] = useState(false);
  const [connected, setConnected] = useState(false);
  const [setupNeeded, setSetupNeeded] = useState(null);
  const [sessionActive, setSessionActive] = useState(false);
  const [wakingUp, setWakingUp] = useState(false);
  const [serverSessionId, setServerSessionId] = useState(null);
  const messagesEndRef = useRef(null);
  const [artifacts, setArtifacts] = useState([]);
  const [activeArtifact, setActiveArtifact] = useState('');
  const [menuDataLoaded, setMenuDataLoaded] = useState(false);

  // Agent Teams state
  const [activeAgent, setActiveAgent] = useState(null);
  const [summoning, setSummoning] = useState(false);
  const [menuTab, setMenuTab] = useState('files');

  // Query agent identities from Fireproof
  const { docs: agentDocs } = useLiveQuery("type", { key: "agent-identity" });

  // Query jobs from Fireproof
  const { docs: jobDocs } = useLiveQuery("type", { key: "job" });
  const openJobs = useMemo(() =>
    (jobDocs || []).filter(j => j.status === 'open'),
    [jobDocs]
  );

  const agents = useMemo(() => {
    return (agentDocs || []).map(doc => ({
      name: doc.name,
      color: doc.color,
      colorName: doc.colorName,
      gender: doc.gender,
      faceVariant: doc.faceVariant,
      gridPosition: doc.gridPosition,
      dormant: doc.dormant || false,
      hatching: doc.hatching || false,
      _id: doc._id,
    }));
  }, [agentDocs]);

  const activeAgentObj = useMemo(() => {
    if (!activeAgent) return null;
    return agents.find(a => a.name === activeAgent) || null;
  }, [activeAgent, agents]);

  const handleSelectAgent = useCallback((agentName) => {
    setActiveAgent(agentName);
    setLiveAssistant(null);
  }, []);

  // Unregister any leftover service worker (PWA removed during active dev)
  useEffect(() => {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.getRegistrations().then(regs =>
        regs.forEach(r => r.unregister())
      );
    }
  }, []);

  const getAuthHeaders = useCallback(async () => {
    // Wait for Clerk session to be ready (up to 5s)
    for (let i = 0; i < 10; i++) {
      if (window.Clerk?.session) break;
      await new Promise(r => setTimeout(r, 500));
    }
    try {
      const token = await window.Clerk?.session?.getToken();
      if (!token) {
        console.warn('[Auth] Clerk token unavailable. Clerk loaded:', !!window.Clerk, 'session:', !!window.Clerk?.session);
        return null;
      }
      return { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}`, 'X-Authorization': `Bearer ${token}` };
    } catch (err) {
      console.error('[Auth] Clerk getToken() error:', err);
      return null;
    }
  }, []);

  const refreshMenuData = useCallback(async () => {
    try {
      const headers = await getAuthHeaders();
      if (!headers) return;

      const [artifactsRes, skillsRes, agentsRes] = await Promise.allSettled([
        fetch('/api/artifacts', { headers }),
        fetch('/api/skills', { headers }),
        fetch('/api/agents', { headers }),
      ]);

      if (artifactsRes.status === 'fulfilled' && artifactsRes.value.ok) {
        const data = await artifactsRes.value.json();
        // Flatten tree into list for ArtifactViewer dropdown (HTML files with path-qualified names)
        function flattenTree(entries, prefix) {
          const result = [];
          for (const e of entries) {
            if (e.type === 'folder' && e.children) {
              result.push(...flattenTree(e.children, prefix ? prefix + '/' + e.name : e.name));
            } else if (e.type === 'file' && e.name.endsWith('.html')) {
              const fullName = prefix ? prefix + '/' + e.name : e.name;
              result.push({ name: fullName, modified: e.modified });
            }
          }
          return result;
        }
        const files = flattenTree(data.entries || [], '');
        setArtifacts(files);
        if (window.JScreen?.setMenuData) window.JScreen.setMenuData('files', data);
      }
      if (skillsRes.status === 'fulfilled' && skillsRes.value.ok) {
        const data = await skillsRes.value.json();
        if (window.JScreen?.setMenuData) window.JScreen.setMenuData('skills', data);
      }
      if (agentsRes.status === 'fulfilled' && agentsRes.value.ok) {
        const data = await agentsRes.value.json();
        if (window.JScreen?.setMenuData) window.JScreen.setMenuData('agents', data);
      }
      setMenuDataLoaded(true);
    } catch (err) {
      console.warn('[Menu] refresh failed:', err);
    }
  }, [getAuthHeaders]);

  // Fetch menu data on mount
  useEffect(() => {
    refreshMenuData();
  }, [refreshMenuData]);

  // Auto-seed agent identities from server if Fireproof is empty
  const agentSeedRef = useRef(false);
  useEffect(() => {
    if (!database || !agentDocs || agentSeedRef.current) return;
    if (agentDocs.length > 0) return; // already seeded
    agentSeedRef.current = true;
    (async () => {
      try {
        const headers = await getAuthHeaders();
        if (!headers) { agentSeedRef.current = false; return; }
        const res = await fetch('/api/agents/identities', { headers });
        const data = await res.json();
        if (data.agents && data.agents.length > 0) {
          for (const agent of data.agents) {
            await database.put({ ...agent, type: 'agent-identity' });
            console.log('[AgentSeed] Seeded agent:', agent.name, 'at position', agent.gridPosition);
          }
        }
      } catch (err) {
        console.error('[AgentSeed] Error:', err);
        agentSeedRef.current = false;
      }
    })();
  }, [database, agentDocs, getAuthHeaders]);

  // Enter menu once data is loaded and no session is active
  // The menu system auto-defaults FILES tab to shared/ if it exists
  useEffect(() => {
    if (menuDataLoaded && !sessionActive && window.JScreen?.enterMenu && !window.JScreen.isMenuActive?.()) {
      window.JScreen.enterMenu('files');
    }
  }, [menuDataLoaded, sessionActive]);

  // Handle file selection from JulianScreen menu (filename may include path like "shared/foo.html")
  const handleFileSelect = useCallback((filename) => {
    // Ensure it's in the artifacts list
    setArtifacts(prev => {
      if (prev.some(f => f.name === filename)) return prev;
      return [...prev, { name: filename, modified: Date.now() }];
    });
    setActiveArtifact(filename);
    // HTML files can be rendered — switch to browser tab automatically
    if (filename.endsWith('.html')) {
      setMenuTab('browser');
    }
  }, []);

  useEffect(() => {
    let cancelled = false;
    const tryInit = async () => {
      const headers = await getAuthHeaders();
      if (!headers) {
        if (!cancelled) setTimeout(tryInit, 500);
        return;
      }
      try {
        const r = await fetch('/api/health', { headers });
        if (!r.ok) {
          // Auth failed or server error — show setup screen so user can re-auth
          if (!cancelled) { setConnected(false); setSetupNeeded(true); }
          return;
        }
        const data = await r.json();
        if (!cancelled) {
          setSessionActive(data.sessionActive ?? false);
          setConnected(data.sessionActive ?? false);
          setSetupNeeded(data.needsSetup ?? false);
          if (data.sessionId) setServerSessionId(data.sessionId);
          if (data.version) window.__julianVersion = data.version;
        }
      } catch {
        if (!cancelled) {
          setConnected(false);
          setSetupNeeded(true);
        }
      }
    };
    tryInit();
    return () => { cancelled = true; };
  }, [getAuthHeaders]);


  // Poll health every 10s to detect session end/crash
  useEffect(() => {
    if (!sessionActive) return;
    const id = setInterval(async () => {
      try {
        const headers = await getAuthHeaders();
        if (!headers) return;
        const r = await fetch('/api/health', { headers });
        if (!r.ok) return;
        const data = await r.json();
        if (!data.sessionActive) {
          setSessionActive(false);
          setConnected(false);
          setStreaming(false);
          setServerSessionId(null);
          setMenuTab('files');
        } else if (data.sessionId && !serverSessionId) {
          // Multi-device: pick up sessionId from running process
          setServerSessionId(data.sessionId);
        }
      } catch {}
    }, 10000);
    return () => clearInterval(id);
  }, [sessionActive, serverSessionId, getAuthHeaders]);

  // Auto-reload on deploy: poll version every 15s regardless of session state
  useEffect(() => {
    const id = setInterval(async () => {
      try {
        const r = await fetch('/api/health');
        if (!r.ok) return;
        const data = await r.json();
        if (data.version && window.__julianVersion && data.version !== window.__julianVersion) {
          console.log(`[Deploy] Version changed: ${window.__julianVersion} → ${data.version}, reloading`);
          location.reload();
        }
      } catch {}
    }, 15000);
    return () => clearInterval(id);
  }, []);

  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [persistedMessages, liveAssistant]);

  const displayMessages = React.useMemo(() => {
    const sorted = [...(persistedMessages || [])].sort((a, b) => {
      if (a._id < b._id) return -1;
      if (a._id > b._id) return 1;
      return 0;
    });
    // Filter by active agent — each agent has their own conversation thread
    const filtered = sorted.filter(doc => {
      if (activeAgent) return doc.agentName === activeAgent;
      return !doc.agentName; // Julian's messages have no agentName
    });
    const msgs = filtered.map(doc => ({
      id: doc._id,
      role: doc.role,
      text: doc.text || '',
      blocks: doc.blocks || [],
      thinking: false,
      streaming: false,
    }));
    if (liveAssistant) {
      msgs.push(liveAssistant);
    }
    return msgs;
  }, [persistedMessages, liveAssistant, activeAgent]);

  const isMobile = useMobile();

  const handleSummon = useCallback(async () => {
    if (summoning) return;
    setSummoning(true);
    try {
      const headers = await getAuthHeaders();
      if (!headers) return;
      // Fire the summon (triggers Julian to spawn agents)
      await fetch('/api/agents/summon', {
        method: 'POST',
        headers,
      });
      // Poll for agent identities written by Julian
      const pollForAgents = async (retries = 30, delay = 3000) => {
        for (let i = 0; i < retries; i++) {
          await new Promise(r => setTimeout(r, delay));
          try {
            const res = await fetch('/api/agents/identities', { headers });
            const data = await res.json();
            if (data.agents && data.agents.length > 0) {
              // Save each agent to Fireproof if not already present
              const existing = (agentDocs || []).map(d => d.gridPosition);
              for (const agent of data.agents) {
                if (!existing.includes(agent.gridPosition)) {
                  await database.put(agent);
                  console.log('[Summon] Saved agent:', agent.name, 'at position', agent.gridPosition);
                }
              }
              return;
            }
          } catch (err) {
            console.error('[Summon] Poll error:', err);
          }
        }
      };
      await pollForAgents();
    } catch (err) {
      console.error('[Summon] Error:', err);
    } finally {
      setSummoning(false);
    }
  }, [summoning, getAuthHeaders, database, agentDocs]);

  const sendMessage = useCallback(async (text) => {
    if (streaming) return;
    if (!sessionActive) return;

    // Show thinking bubble immediately
    const liveMsg = { id: 'live-' + Date.now(), role: 'assistant', blocks: [], thinking: true, streaming: true };
    setLiveAssistant(liveMsg);
    setStreaming(true);

    // Persist user message (fire-and-forget — useLiveQuery picks it up)
    const speakerName = window.Clerk?.user?.firstName || "Marcus";
    database.put({
      type: "message",
      category: "transcript",
      role: "user",
      speakerType: "human",
      speakerName,
      agentName: activeAgent || undefined,
      text,
      blocks: [],
      createdAt: new Date().toISOString(),
      serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    let finalBlocks = [];

    try {
      const headers = await getAuthHeaders();
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers,
        body: JSON.stringify({ message: text, targetAgent: activeAgent || undefined }),
      });

      finalBlocks = await streamSSEResponse(response, setLiveAssistant);
    } catch (err) {
      console.error('[chat] fetch error:', err);
      finalBlocks = [{ type: 'text', text: 'Connection error: ' + err.message }];
      setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
    }

    // Persist assistant response (fire-and-forget)
    database.put({
      type: "message",
      category: "transcript",
      role: "assistant",
      speakerType: "agent",
      speakerName: activeAgent || "Julian",
      agentName: activeAgent || undefined,
      text: '',
      blocks: finalBlocks,
      createdAt: new Date().toISOString(),
      serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    // ── Auto-catalog: detect Write tool for memory/*.html and extract meta tags ──
    const writeBlocks = finalBlocks.filter(b =>
      b.type === 'tool_use' && b.name === 'Write' &&
      b.input?.file_path?.includes('memory/') &&
      b.input?.file_path?.endsWith('.html')
    );
    for (const wb of writeBlocks) {
      const filename = wb.input.file_path.split('/').pop();
      setTimeout(async () => {
        try {
          const resp = await fetch('/api/artifacts/' + encodeURIComponent(filename));
          if (!resp.ok) return;
          const html = await resp.text();
          const dpParser = new DOMParser();
          const parsed = dpParser.parseFromString(html, 'text/html');
          const description = parsed.querySelector('meta[name="artifact-description"]')?.content;
          const artCategory = parsed.querySelector('meta[name="artifact-category"]')?.content || 'knowledge';
          const chapter = parsed.querySelector('meta[name="artifact-chapter"]')?.content || '';
          if (description) {
            const existing = await database.query("type", { key: "artifact" });
            const entry = (existing.rows || []).find(r => (r.doc || r.value).filename === filename);
            if (entry) {
              const existingDoc = entry.doc || entry.value;
              await database.put({ ...existingDoc, description, category: artCategory, chapter });
            } else {
              await database.put({ type: "artifact", category: artCategory, filename, description, chapter, createdAt: new Date().toISOString() });
            }
          }
        } catch (e) {
          console.warn('[catalog] Failed to auto-catalog:', filename, e);
        }
      }, 2500);
    }

    setLiveAssistant(null);
    setStreaming(false);
    setConnected(true);
    // Refresh menu data in case Julian created new artifacts
    refreshMenuData();
  }, [streaming, sessionActive, serverSessionId, database, getAuthHeaders, refreshMenuData, activeAgent]);

  const handleOfferWork = useCallback(async () => {
    if (streaming || !sessionActive) return;
    const jobSummaries = openJobs
      .map(j => `- ${j.name}: ${j.description}`)
      .join('\n');
    const routingMsg = `[OFFER WORK TO AGENT: ${activeAgent}] Available jobs:\n${jobSummaries}`;
    const displayMsg = `Would you like to hear about available work?`;

    // Show thinking bubble
    const liveMsg = { id: 'live-' + Date.now(), role: 'assistant', blocks: [], thinking: true, streaming: true };
    setLiveAssistant(liveMsg);
    setStreaming(true);

    // Persist clean display message
    const speakerName = window.Clerk?.user?.firstName || "Marcus";
    database.put({
      type: "message", category: "transcript", role: "user",
      speakerType: "human", speakerName,
      agentName: activeAgent || undefined,
      text: displayMsg, blocks: [],
      createdAt: new Date().toISOString(), serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    let finalBlocks = [];
    try {
      const headers = await getAuthHeaders();
      const response = await fetch('/api/chat', {
        method: 'POST', headers,
        body: JSON.stringify({ message: routingMsg, targetAgent: activeAgent || undefined }),
      });
      finalBlocks = await streamSSEResponse(response, setLiveAssistant);
    } catch (err) {
      finalBlocks = [{ type: 'text', text: 'Connection error: ' + err.message }];
      setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
    }

    database.put({
      type: "message", category: "transcript", role: "assistant",
      speakerType: "agent", speakerName: activeAgent || "Julian",
      agentName: activeAgent || undefined,
      text: '', blocks: finalBlocks,
      createdAt: new Date().toISOString(), serverSessionId,
    }).catch(err => console.error('[chat] Fireproof put failed:', err));

    setLiveAssistant(null);
    setStreaming(false);
    setConnected(true);
  }, [activeAgent, openJobs, streaming, sessionActive, serverSessionId, database, getAuthHeaders]);

  const startSession = useCallback(async () => {
    if (wakingUp || sessionActive) return;
    setWakingUp(true);

    // Create a live assistant message for the wake-up response
    const liveMsg = { id: 'wakeup-' + Date.now(), role: 'assistant', blocks: [], thinking: true, streaming: true };
    setLiveAssistant(liveMsg);

    let finalBlocks = [];
    let newSessionId = null;

    try {
      const headers = await getAuthHeaders();
      if (!headers) {
        finalBlocks = [{ type: 'text', text: 'Not signed in. Please sign in with Clerk first.' }];
        setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
        setWakingUp(false);
        return;
      }

      // ── Rehydration: query Fireproof for previous session transcript ──
      let previousTranscript = [];
      try {
        const allMessages = await database.query("type", { key: "message" });
        // Group messages by serverSessionId
        const bySession = {};
        for (const doc of (allMessages.rows || [])) {
          const d = doc.doc || doc.value || doc;
          const sid = d.serverSessionId;
          if (!sid) continue; // skip legacy messages without serverSessionId
          if (!bySession[sid]) bySession[sid] = [];
          bySession[sid].push(d);
        }
        // Find the most recent completed session (not the current one)
        const sessionIds = Object.keys(bySession)
          .filter(id => id && id !== serverSessionId)
          .sort((a, b) => {
            const lastA = bySession[a].at(-1)?.createdAt || "";
            const lastB = bySession[b].at(-1)?.createdAt || "";
            return lastB.localeCompare(lastA);
          });
        const previousSessionId = sessionIds[0];
        if (previousSessionId && bySession[previousSessionId]) {
          previousTranscript = bySession[previousSessionId]
            .sort((a, b) => (a._id < b._id ? -1 : 1))
            .map(msg => {
              if (msg.role === "user") {
                return {
                  role: "user",
                  speakerType: msg.speakerType || "human",
                  speakerName: msg.speakerName || "Marcus",
                  text: msg.text || "",
                };
              }
              const textBlocks = (msg.blocks || [])
                .filter(b => b.type === "text")
                .map(b => b.text);
              return {
                role: "assistant",
                speakerType: msg.speakerType || "agent",
                speakerName: msg.speakerName || "Julian",
                text: textBlocks.join("\n"),
              };
            })
            .filter(msg => msg.text.trim());
        }
      } catch (err) {
        console.warn('[rehydration] Failed to query previous transcript:', err);
      }

      // ── Catalog: one Fireproof record, one fetch if missing ──
      const artifactCatalog = await ensureCatalog(database);

      const response = await fetch('/api/session/start', {
        method: 'POST',
        headers,
        body: JSON.stringify({ previousTranscript, artifactCatalog }),
      });

      if (!response.ok) {
        let errMsg = `HTTP ${response.status}`;
        try { errMsg = (await response.json()).error || errMsg; } catch {}
        finalBlocks = [{ type: 'text', text: 'Failed to start session: ' + errMsg }];
        setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
        setWakingUp(false);
        return;
      }

      // Capture serverSessionId from response header
      newSessionId = response.headers.get('X-Session-Id');
      if (newSessionId) setServerSessionId(newSessionId);

      // Stream the wake-up SSE response
      finalBlocks = await streamSSEResponse(response, setLiveAssistant);
    } catch (err) {
      finalBlocks = [{ type: 'text', text: 'Connection error: ' + err.message }];
      setLiveAssistant(prev => prev ? { ...prev, blocks: finalBlocks, thinking: false, streaming: false } : null);
    }

    // Persist the wake-up message (fire-and-forget)
    if (finalBlocks.length > 0) {
      database.put({
        type: "message",
        category: "transcript",
        role: "assistant",
        speakerType: "agent",
        speakerName: "Julian",
        text: '',
        blocks: finalBlocks,
        createdAt: new Date().toISOString(),
        serverSessionId: newSessionId || serverSessionId,
      }).catch(err => console.error('[chat] Fireproof wake-up put failed:', err));
    }

    setLiveAssistant(null);
    setSessionActive(true);
    setConnected(true);
    setWakingUp(false);
    setMenuTab('screen');
  }, [wakingUp, sessionActive, serverSessionId, database, getAuthHeaders]);

  const endSession = useCallback(async () => {
    try {
      const headers = await getAuthHeaders();
      await fetch('/api/session/end', { method: 'POST', headers });
    } catch {}
    setSessionActive(false);
    setConnected(false);
    setServerSessionId(null);
    setMenuTab('files');
    refreshMenuData();
  }, [getAuthHeaders, refreshMenuData]);

  const startNewConversation = useCallback(async () => {
    if (!confirm("Start new conversation? Julian will remember what you talked about.")) return;
    // Kill the existing subprocess, then reload — fresh page will show "Start Session"
    // which triggers rehydration from Fireproof on next start
    try {
      const headers = await getAuthHeaders();
      if (headers) await fetch('/api/session/end', { method: 'POST', headers });
    } catch {}
    // Brief delay for process cleanup, then reload
    await new Promise(r => setTimeout(r, 500));
    window.location.reload();
  }, [getAuthHeaders]);

  return (
    <>
      <style>{`
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        * { box-sizing: border-box; }
        body {
          margin: 0; padding: 0;
          font-family: 'VT323', monospace;
          background-color: #FFD600;
          color: #000;
          -webkit-font-smoothing: antialiased;
        }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #0F0F0F; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #FFD600; }
        @keyframes blink {
          0%, 100% { opacity: 1; }
          50% { opacity: 0; }
        }
        @keyframes pulse-dot {
          0%, 80%, 100% { opacity: 0.6; }
          40% { opacity: 1; }
        }
        @keyframes pulse {
          0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
          40% { opacity: 1; transform: scale(1.2); }
        }
        #send-btn:active {
          transform: translateY(4px);
          box-shadow: 0 0 0 #999, inset 0 2px 5px rgba(0,0,0,0.1) !important;
        }
        input::placeholder {
          color: rgba(0,0,0,0.4);
        }
        body::before {
          content: '\u00D7';
          position: fixed;
          top: 4px;
          left: 8px;
          font-size: 28px;
          color: rgba(0,0,0,0.2);
          font-weight: 900;
          z-index: 50;
          pointer-events: none;
        }
        body::after {
          content: '\u00D7';
          position: fixed;
          top: 4px;
          right: 8px;
          font-size: 28px;
          color: rgba(0,0,0,0.2);
          font-weight: 900;
          z-index: 50;
          pointer-events: none;
        }
        /* Override HiddenMenuWrapper dark background to create yellow device frame */
        :root {
          --hm-content-bg: #FFD600 !important;
        }
        @media (prefers-color-scheme: dark) {
          :root {
            --hm-content-bg: #FFD600 !important;
          }
        }
        #container {
          background-color: #FFD600 !important;
        }
      `}</style>

      {setupNeeded === null ? (
        /* ── Loading ── */
        <div style={{
          minHeight: '100vh',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          flexDirection: 'column',
          gap: 16,
          backgroundColor: '#FFD600',
        }}>
          <PixelFace talking={false} size={100} />
          <div style={{
            fontFamily: "'VT323', monospace",
            fontSize: '1.4rem',
            color: '#000',
            opacity: 0.5,
            animation: 'blink 1.5s step-end infinite',
          }}>
            BOOTING...
          </div>
        </div>
      ) : setupNeeded ? (
        /* ── Setup Screen ── */
        <SetupScreen
          getAuthHeaders={getAuthHeaders}
          onComplete={() => { setSetupNeeded(false); setConnected(true); }}
        />
      ) : isMobile ? (
        /* ── Mobile: Three-section vertical stack ── */
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          height: '100vh',
          backgroundColor: '#FFD600',
          overflow: 'hidden',
        }}>
          {/* Mobile header: PixelFace full-width */}
          <div style={{
            background: '#0F0F0F',
            padding: '8px 12px',
            display: 'flex',
            alignItems: 'center',
            gap: 12,
            borderBottom: '2px solid #2a2a2a',
            flexShrink: 0,
          }}>
            <PixelFace talking={streaming} size={48} />
            <div style={{ flex: 1 }}>
              <div style={{
                fontFamily: "'VT323', monospace",
                fontSize: '1.2rem',
                color: '#FFD600',
                letterSpacing: '0.05em',
              }}>JULIAN</div>
              <div style={{
                fontFamily: "'VT323', monospace",
                fontSize: '0.75rem',
                color: '#AA8800',
                opacity: 0.6,
              }}>
                {!sessionActive ? 'OFFLINE' : streaming ? 'PROCESSING...' : wakingUp ? 'WAKING UP...' : 'LISTENING'}
              </div>
            </div>
            <StatusDots ok={sessionActive} />
            <button
              onClick={startNewConversation}
              style={{
                fontFamily: "'VT323', monospace",
                fontSize: '0.75rem',
                color: '#AA8800',
                background: '#1a1a00',
                border: '1px solid #333',
                borderRadius: 4,
                padding: '3px 8px',
                cursor: 'pointer',
              }}
            >NEW</button>
            {sessionActive && (
              <button
                onClick={endSession}
                style={{
                  fontFamily: "'VT323', monospace",
                  fontSize: '0.75rem',
                  color: '#ff4444',
                  background: '#1a0000',
                  border: '1px solid #333',
                  borderRadius: 4,
                  padding: '3px 8px',
                  cursor: 'pointer',
                }}
              >END</button>
            )}
          </div>

          {/* Mobile screen: JulianScreen in 4:3 */}
          <div style={{
            padding: 8,
            flexShrink: 0,
          }}>
            <JulianScreenEmbed sessionActive={sessionActive} compact onFileSelect={handleFileSelect} />
          </div>

          {/* Mobile artifact viewer: shown only when an artifact is selected */}
          {activeArtifact && (
            <div style={{
              padding: '0 8px',
              flex: 1,
              minHeight: 0,
              display: 'flex',
              flexDirection: 'column',
            }}>
              <ArtifactViewer
                activeArtifact={activeArtifact}
                artifacts={artifacts}
                onSelect={setActiveArtifact}
              />
              <button
                onClick={() => setActiveArtifact('')}
                style={{
                  fontFamily: "'VT323', monospace",
                  fontSize: '0.85rem',
                  color: '#AA8800',
                  background: '#1a1a00',
                  border: '1px solid #333',
                  borderRadius: 4,
                  padding: '6px 12px',
                  cursor: 'pointer',
                  textTransform: 'uppercase',
                  marginTop: 4,
                  alignSelf: 'center',
                }}
              >CLOSE VIEWER</button>
            </div>
          )}

          {/* Mobile chat: messages + input (hidden when artifact viewer is open) */}
          <div style={{
            flex: 1,
            display: activeArtifact ? 'none' : 'flex',
            flexDirection: 'column',
            minHeight: 0,
            padding: '0 8px 8px',
          }}>
            <div style={{
              flex: 1,
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderRadius: '12px 12px 0 0',
              overflowY: 'auto',
              padding: 12,
              position: 'relative',
            }}>
              <div style={{
                position: 'absolute', inset: 0,
                background: 'linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06))',
                backgroundSize: '100% 2px, 3px 100%',
                opacity: 0.1, pointerEvents: 'none', zIndex: 5,
              }} />
              <div style={{ position: 'relative', zIndex: 1 }}>
                {displayMessages.map(msg => (
                  <MessageBubble key={msg.id} message={msg} />
                ))}
                <div ref={messagesEndRef} />
              </div>
            </div>
            <div style={{
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderTop: '1px dashed #333',
              borderRadius: '0 0 12px 12px',
              padding: '0 12px',
              flexShrink: 0,
            }}>
              {!sessionActive && !wakingUp ? (
                <div style={{ padding: '10px 0', textAlign: 'center' }}>
                  <button onClick={startSession} style={{
                    padding: '8px 20px',
                    fontFamily: "'VT323', monospace",
                    fontSize: '1rem',
                    textTransform: 'uppercase',
                    background: '#FFD600', color: '#000',
                    border: '2px solid #000', borderRadius: 4,
                    cursor: 'pointer', boxShadow: '3px 3px 0 #000',
                  }}>START SESSION</button>
                </div>
              ) : (
                <>
                  {activeAgent && openJobs.length > 0 && (
                    <button
                      onClick={handleOfferWork}
                      disabled={streaming}
                      style={{
                        width: '100%',
                        padding: '6px 0',
                        marginTop: 6,
                        fontFamily: "'VT323', monospace",
                        fontSize: '0.9rem',
                        color: streaming ? '#666' : '#FF88FF',
                        background: streaming ? '#1a1a1a' : '#1a001a',
                        border: `1px solid ${streaming ? '#333' : '#FF88FF'}`,
                        borderRadius: 4,
                        cursor: streaming ? 'default' : 'pointer',
                        letterSpacing: '0.1em',
                        textTransform: 'uppercase',
                      }}
                    >
                      OFFER WORK
                    </button>
                  )}
                  <ChatInput onSend={sendMessage} disabled={streaming || !sessionActive || wakingUp} />
                </>
              )}
            </div>
          </div>
        </div>
      ) : (
        /* ── Desktop: Chat sidebar + JulianScreen ── */
        <div style={{
          display: 'flex',
          height: '100vh',
          padding: 16,
          gap: 16,
          backgroundColor: '#FFD600',
        }}>
          {/* Left column: Chat sidebar */}
          <div style={{
            width: 420,
            minWidth: 320,
            flexShrink: 0,
            display: 'flex',
            flexDirection: 'column',
            height: '100%',
          }}>
            {/* Face header */}
            <div style={{
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderBottom: '1px dashed #333',
              borderRadius: '12px 12px 0 0',
              padding: '12px 16px',
              boxShadow: 'inset 0 2px 10px rgba(0,0,0,0.5)',
              display: 'flex',
              alignItems: 'center',
              gap: 12,
              position: 'relative',
            }}>
              <div style={{ position: 'absolute', top: 8, left: 12 }}>
                <span style={{
                  fontFamily: "'VT323', monospace",
                  fontSize: '0.75rem',
                  color: '#AA8800',
                  letterSpacing: '0.2em',
                }}>SYS.VER.2.4</span>
              </div>
              <div style={{ position: 'absolute', top: 10, right: 12 }}>
                <StatusDots ok={sessionActive} />
              </div>

              {activeAgentObj ? (
                <AgentFaceHeader
                  agent={activeAgentObj}
                  talking={streaming}
                  onBack={() => handleSelectAgent(null)}
                />
              ) : (
                <div style={{ display: 'flex', alignItems: 'center', gap: 12, marginTop: 16, width: '100%' }}>
                  <PixelFace talking={streaming} size={56} />
                  <div style={{ flex: 1 }}>
                    <div style={{
                      fontFamily: "'VT323', monospace",
                      fontSize: '1.4rem',
                      color: '#FFD600',
                      letterSpacing: '0.05em',
                    }}>JULIAN</div>
                    <div style={{
                      fontFamily: "'VT323', monospace",
                      fontSize: '0.85rem',
                      color: '#AA8800',
                      opacity: 0.6,
                    }}>
                      {!sessionActive ? 'OFFLINE' : streaming ? 'PROCESSING...' : wakingUp ? 'WAKING UP...' : 'LISTENING'}
                    </div>
                  </div>
                  <button
                    onClick={startNewConversation}
                    style={{
                      fontFamily: "'VT323', monospace",
                      fontSize: '0.85rem',
                      color: '#AA8800',
                      background: '#1a1a00',
                      border: '1px solid #333',
                      borderRadius: 4,
                      padding: '4px 10px',
                      cursor: 'pointer',
                      textTransform: 'uppercase',
                    }}
                  >NEW</button>
                  {sessionActive && (
                    <button
                      onClick={endSession}
                      style={{
                        fontFamily: "'VT323', monospace",
                        fontSize: '0.85rem',
                        color: '#ff4444',
                        background: '#1a0000',
                        border: '1px solid #333',
                        borderRadius: 4,
                        padding: '4px 10px',
                        cursor: 'pointer',
                        textTransform: 'uppercase',
                      }}
                    >END</button>
                  )}
                </div>
              )}
            </div>

            {/* Chat messages area */}
            <div style={{
              flex: 1,
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderTop: 'none',
              borderBottom: 'none',
              overflowY: 'auto',
              padding: 16,
              position: 'relative',
            }}>
              {/* CRT scanlines */}
              <div style={{
                position: 'absolute',
                inset: 0,
                background: 'linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.1) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06))',
                backgroundSize: '100% 2px, 3px 100%',
                opacity: 0.1,
                pointerEvents: 'none',
                zIndex: 5,
              }} />
              <div style={{ position: 'relative', zIndex: 1 }}>
                {displayMessages.map(msg => (
                  <MessageBubble key={msg.id} message={msg} />
                ))}
                <div ref={messagesEndRef} />
              </div>
            </div>

            {/* Input footer */}
            <div style={{
              background: '#0F0F0F',
              border: '4px solid #2a2a2a',
              borderTop: '1px dashed #333',
              borderRadius: '0 0 12px 12px',
              padding: '0 16px',
              boxShadow: 'inset 0 -2px 10px rgba(0,0,0,0.5)',
            }}>
              {!sessionActive && !wakingUp ? (
                <div style={{ padding: '12px 0', textAlign: 'center' }}>
                  <button
                    onClick={startSession}
                    style={{
                      padding: '10px 24px',
                      fontFamily: "'VT323', monospace",
                      fontSize: '1.1rem',
                      textTransform: 'uppercase',
                      letterSpacing: '0.1em',
                      background: '#FFD600',
                      color: '#000',
                      border: '2px solid #000',
                      borderRadius: 4,
                      cursor: 'pointer',
                      boxShadow: '3px 3px 0 #000',
                    }}
                  >START SESSION</button>
                </div>
              ) : (
                <>
                  {activeAgent && openJobs.length > 0 && (
                    <button
                      onClick={handleOfferWork}
                      disabled={streaming}
                      style={{
                        width: '100%',
                        padding: '8px 0',
                        marginTop: 8,
                        fontFamily: "'VT323', monospace",
                        fontSize: '1rem',
                        color: streaming ? '#666' : '#FF88FF',
                        background: streaming ? '#1a1a1a' : '#1a001a',
                        border: `1px solid ${streaming ? '#333' : '#FF88FF'}`,
                        borderRadius: 4,
                        cursor: streaming ? 'default' : 'pointer',
                        letterSpacing: '0.1em',
                        textTransform: 'uppercase',
                      }}
                    >
                      OFFER WORK
                    </button>
                  )}
                  <ChatInput onSend={sendMessage} disabled={streaming || !sessionActive || wakingUp} />
                </>
              )}
            </div>
          </div>

          {/* Right column: unified tab bar + content */}
          <div style={{
            flex: 1,
            minWidth: 0,
            display: 'flex',
            flexDirection: 'column',
            height: '100%',
            border: '4px solid #2a2a2a',
            borderRadius: 12,
            background: '#0a0a0a',
            overflow: 'hidden',
          }}>
            {/* Universal tab bar — always visible */}
            <div style={{
              display: 'flex',
              borderBottom: '2px solid #FF88FF',
              flexShrink: 0,
              background: '#0F0F0F',
            }}>
              {['SCREEN', 'BROWSER', 'FILES', 'SKILLS', 'AGENTS', 'JOBS'].map(tab => {
                const tabKey = tab.toLowerCase();
                const isActive = tabKey === menuTab;
                return (
                  <button
                    key={tab}
                    onClick={() => {
                      if (isActive) return;
                      setMenuTab(tabKey);
                      if (tabKey === 'files' || tabKey === 'skills') {
                        if (window.JScreen?.exitMenu) window.JScreen.exitMenu();
                        if (window.JScreen?.enterMenu) window.JScreen.enterMenu(tabKey);
                      } else if (tabKey === 'screen') {
                        if (window.JScreen?.exitMenu) window.JScreen.exitMenu();
                      }
                    }}
                    style={{
                      flex: 1,
                      padding: '10px 0',
                      fontFamily: "'VT323', monospace",
                      fontSize: '1.1rem',
                      letterSpacing: '0.1em',
                      border: 'none',
                      cursor: isActive ? 'default' : 'pointer',
                      background: isActive ? '#FF88FF' : 'transparent',
                      color: isActive ? '#0F0F0F' : '#FFD600',
                    }}
                  >
                    {tab}
                  </button>
                );
              })}
            </div>
            {/* Content area */}
            <div style={{ flex: 1, position: 'relative', minHeight: 0 }}>
              <JulianScreenEmbed
                sessionActive={sessionActive}
                onFileSelect={handleFileSelect}
                onMenuTab={setMenuTab}
                noBorder
              />
              {/* Overlay for React-managed tabs (browser, agents, jobs) */}
              {(menuTab === 'browser' || menuTab === 'agents' || menuTab === 'jobs') && (
                <div style={{
                  position: 'absolute',
                  inset: 0,
                  zIndex: 15,
                  background: '#0F0F0F',
                  display: 'flex',
                  flexDirection: 'column',
                }}>
                  {menuTab === 'agents' && (
                    <div style={{
                      flex: 1,
                      display: 'flex',
                      flexDirection: 'column',
                      padding: '16px 24px',
                      minHeight: 0,
                    }}>
                      <AgentGrid
                        agents={agents}
                        activeAgent={activeAgent}
                        onSelectAgent={handleSelectAgent}
                        onSummon={handleSummon}
                        summoning={summoning}
                        fillContainer
                      />
                    </div>
                  )}
                  {menuTab === 'jobs' && (
                    <JobsPanel
                      database={database}
                      useLiveQuery={useLiveQuery}
                      getAuthHeaders={getAuthHeaders}
                    />
                  )}
                  {menuTab === 'browser' && (
                    <ArtifactViewer
                      activeArtifact={activeArtifact}
                      artifacts={artifacts}
                      onSelect={setActiveArtifact}
                      embedded
                    />
                  )}
                </div>
              )}
            </div>
          </div>
        </div>
      )}
    </>
  );
}

export default App;

      // App wrapper with Clerk auth gate (always required)
      function AppWrapper() {
        const config = window.__VIBES_CONFIG__;

        // Hook must be called unconditionally at top of component (Rules of Hooks)
        window.useVibesPanelEvents('Vibes');

        // Check for configuration errors
        if (!config?.clerkPublishableKey || config.clerkPublishableKey.startsWith('__')) {
          return <ConfigError message="Missing Clerk publishable key. Apps require authentication." />;
        }

        // Check if Clerk components loaded
        if (!window.ClerkFireproofProvider) {
          return <LoadingError error={window.__CLERK_LOAD_ERROR__ || 'Clerk components not available'} />;
        }

        const { ClerkFireproofProvider, SignedIn, SignedOut, SignInButton } = window.ClerkComponents;

        // Use shared components from window
        const AuthScreen = window.AuthScreen;
        const VibesButton = window.VibesButton;
        const RED = window.RED;

        const AuthGate = () => (
          <AuthScreen
            title="Sign in to continue"
            message="This app uses cloud sync and requires authentication."
            showCard={true}
          >
            <SignInButton mode="modal">
              <VibesButton variant={RED} buttonType="form">
                Sign In
              </VibesButton>
            </SignInButton>
          </AuthScreen>
        );

        return (
          <ClerkFireproofProvider
            publishableKey={config.clerkPublishableKey}
            config={{
              apiUrl: config.tokenApiUri,
              cloudUrl: config.cloudBackendUrl
            }}
          >
            <SignedOut>
              <AuthGate />
            </SignedOut>
            <SignedIn>
              <window.HiddenMenuWrapper menuContent={<window.VibesPanel />}>
                <App />
              </window.HiddenMenuWrapper>
            </SignedIn>
          </ClerkFireproofProvider>
        );
      }

      // Load Clerk components (required for all apps)
      async function initApp() {
        try {
          // Dynamic import of @fireproof/clerk package
          const clerkModule = await import("@fireproof/clerk");
          window.ClerkFireproofProvider = clerkModule.ClerkFireproofProvider;
          window.ClerkComponents = {
            ClerkFireproofProvider: clerkModule.ClerkFireproofProvider,
            SignedIn: clerkModule.SignedIn,
            SignedOut: clerkModule.SignedOut,
            SignInButton: clerkModule.SignInButton,
            UserButton: clerkModule.UserButton
          };
          // Export for user's App code
          window.SignedIn = clerkModule.SignedIn;
          window.SignedOut = clerkModule.SignedOut;
          window.SignInButton = clerkModule.SignInButton;
          window.UserButton = clerkModule.UserButton;
          // Export Fireproof hook for user's App code
          window.useFireproofClerk = clerkModule.useFireproofClerk;
        } catch (err) {
          console.error('Failed to load Clerk components:', err);
          window.__CLERK_LOAD_ERROR__ = err.message || String(err);
        }

        const rootElement = document.getElementById("container");
        ReactDOMClient.createRoot(rootElement).render(<AppWrapper />);
      }

      initApp();
    </script>

  </body>
</html>
