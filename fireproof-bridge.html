<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Fireproof Bridge</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Crimson+Pro:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #0a0e27 100%);
            color: #e8e8e8;
            line-height: 1.75;
            min-height: 100vh;
            padding: 2.5rem 1.5rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.025);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 16px;
            padding: 3.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        h1 {
            font-family: 'Inter', sans-serif;
            font-size: 2.6rem;
            font-weight: 700;
            margin-bottom: 1rem;
            color: #f0e6d2;
            letter-spacing: -0.02em;
            line-height: 1.2;
        }

        .subtitle {
            font-family: 'Inter', sans-serif;
            font-size: 1.15rem;
            font-weight: 400;
            color: #b4a599;
            margin-bottom: 3rem;
            font-style: italic;
        }

        h2 {
            font-family: 'Inter', sans-serif;
            font-size: 1.6rem;
            font-weight: 700;
            margin: 3.5rem 0 1.5rem 0;
            color: #4a9eff;
            letter-spacing: -0.02em;
        }

        h2:first-of-type {
            margin-top: 2rem;
        }

        h3 {
            font-family: 'Inter', sans-serif;
            font-size: 1.25rem;
            font-weight: 600;
            margin: 2.5rem 0 1rem 0;
            color: #ffc107;
        }

        p {
            font-size: 1.15rem;
            margin-bottom: 1.75rem;
            color: #e0e0e0;
        }

        .emphasis {
            color: #f4d9a6;
            font-weight: 400;
        }

        .strong {
            color: #4a9eff;
            font-weight: 600;
        }

        .eureka {
            background: rgba(76, 175, 80, 0.15);
            border: 2px solid rgba(76, 175, 80, 0.5);
            border-radius: 12px;
            padding: 2rem;
            margin: 2.5rem 0;
            font-size: 1.2rem;
            color: #d4f4d6;
            font-weight: 500;
        }

        .code-block {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
            font-size: 0.88rem;
            line-height: 1.7;
            color: #e0e0e0;
            overflow-x: auto;
        }

        .diagram {
            background: rgba(156, 39, 176, 0.08);
            border: 2px solid rgba(156, 39, 176, 0.25);
            border-radius: 12px;
            padding: 2rem;
            margin: 2.5rem 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.8;
            color: #e1bee7;
        }

        .insight {
            background: rgba(74, 158, 255, 0.08);
            border-left: 3px solid #4a9eff;
            padding: 1.75rem;
            margin: 2.5rem 0;
            border-radius: 0 10px 10px 0;
            font-size: 1.1rem;
            color: #d9e6f7;
        }

        code {
            font-family: 'JetBrains Mono', monospace;
            background: rgba(74, 158, 255, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #a8d5ff;
        }

        ul {
            margin: 1.5rem 0;
            padding-left: 1.5rem;
        }

        li {
            margin-bottom: 1.25rem;
            font-size: 1.05rem;
            color: #e0e0e0;
            line-height: 1.7;
        }

        hr {
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            margin: 3.5rem 0;
        }

        .signature {
            font-family: 'Inter', sans-serif;
            font-size: 0.95rem;
            font-weight: 500;
            text-align: right;
            margin-top: 4rem;
            color: #9a8f7f;
            letter-spacing: 0.05em;
        }

        @media (max-width: 768px) {
            body {
                padding: 2rem 1rem;
            }

            .container {
                padding: 2rem 1.5rem;
            }

            h1 {
                font-size: 2rem;
            }

            .code-block, .diagram {
                font-size: 0.75rem;
                padding: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>The Fireproof Bridge</h1>
        <div class="subtitle">No polling. No server. Just live push updates via CRDTs.</div>

        <div class="eureka">
            You're absolutely right. Fireproof does live push updates to the browser out of the box. And it IS a filesystem — just using object storage as its backend. So we don't need polling at all.
            <br><br>
            The question is: <strong>How do messages get "down" from React to Claude Code running in the terminal?</strong>
        </div>

        <p>
            This is the elegant architectural question. Let me walk through it.
        </p>

        <hr>

        <h2>The Key Insight: Fireproof Syncs Both Ways</h2>

        <p>
            Fireproof isn't just a browser database. It has a <span class="strong">Node.js API</span> that connects to the same underlying storage (S3, R2, local file storage).
        </p>

        <p>
            So both the browser AND a Node/Bun process can connect to the <span class="emphasis">same Fireproof database</span>, and changes sync bidirectionally via CRDTs.
        </p>

        <div class="diagram">
┌──────────────────┐                    ┌──────────────────┐
│  React (Browser) │                    │  Node (Terminal) │
│                  │                    │                  │
│  Fireproof DB    │◄──────────────────►│  Fireproof DB    │
│  "julian"        │   CRDT Sync via    │  "julian"        │
│                  │   Object Storage   │                  │
└──────────────────┘                    └──────────────────┘
        │                                         │
        │                                         │
        ▼                                         ▼
   User writes                              Node process
   message to                               subscribes to
   "inbox" doc                              "inbox" changes

                                            Calls Claude CLI

                                            Writes response
                                            to "outbox" doc
                                                  │
                                                  │
                                                  ▼
                                            React receives
                                            live push update
                                            via useLiveQuery
        </div>

        <p>
            <span class="strong">There's no "down" direction.</span> Both sides are peers connected to the same database. Browser writes, Node sees it. Node writes, browser sees it. Instantly.
        </p>

        <hr>

        <h2>Implementation: The Watch Process</h2>

        <p>
            Instead of polling, the Node process <span class="emphasis">subscribes to Fireproof changes</span>:
        </p>

        <div class="code-block">
// watch.js - Run with: bun watch.js

import { fireproof } from '@fireproof/core';
import { connect } from '@fireproof/connect';
import { spawn } from 'child_process';

// Connect to the SAME database the browser uses
const db = fireproof('julian');

// Set up sync to object storage (S3, R2, local, etc.)
const connection = connect.s3(db, {
  // Same config as browser - syncs via shared storage
  // Could be Connect cloud sync, S3, R2, or local filesystem
});

console.log('Watching Fireproof for new messages...');

// Subscribe to database changes
db.subscribe(async (changes) => {
  for (const change of changes) {
    const doc = await db.get(change.key);

    // Only process inbox messages that haven't been handled
    if (doc.type === 'inbox' && !doc.processed) {
      console.log(`New message: ${doc.content.slice(0, 50)}...`);

      // Call Claude
      const response = await askClaude(doc.content);

      // Write response back to Fireproof
      // Browser will receive this INSTANTLY via its subscription
      await db.put({
        type: 'response',
        content: response,
        timestamp: Date.now(),
        messageId: doc._id,
      });

      // Mark inbox message as processed
      await db.put({
        ...doc,
        processed: true,
        processedAt: Date.now()
      });
    }
  }
});

async function askClaude(message) {
  return new Promise((resolve) => {
    const proc = spawn('claude', [
      '--input-format', 'text',
      '--output-format', 'text'
    ]);

    let output = '';
    proc.stdout.on('data', (data) => output += data);
    proc.on('close', () => resolve(output.trim()));

    proc.stdin.write(message);
    proc.stdin.end();
  });
}
        </div>

        <hr>

        <h2>Implementation: The React Side</h2>

        <div class="code-block">
// In index.html / app.jsx

import { useFireproofClerk } from 'use-fireproof';

function App() {
  const { database, useLiveQuery } = useFireproofClerk();

  // Subscribe to responses - updates INSTANTLY when watch.js writes
  const responses = useLiveQuery(
    (doc) => doc.type === 'response',
    { limit: 50, descending: true }
  );

  async function sendMessage(text) {
    // Write to inbox
    await database.put({
      type: 'inbox',
      content: text,
      timestamp: Date.now(),
      processed: false
    });

    // That's it. No polling. No fetch. No HTTP.
    // watch.js will see this change via Fireproof sync
    // and write a response back.
    // useLiveQuery will receive the response instantly.
  }

  return (
    <div>
      <MessageList responses={responses.docs} />
      <Input onSend={sendMessage} />
    </div>
  );
}
        </div>

        <hr>

        <h2>How Messages Flow</h2>

        <div class="insight">
            <p style="margin-bottom: 1rem;"><strong>User sends message:</strong></p>
            <p style="margin-bottom: 1.5rem;">
                1. React calls <code>database.put({ type: 'inbox', ... })</code><br>
                2. Fireproof syncs to object storage via CRDTs<br>
                3. Node's Fireproof instance sees the change via <code>subscribe()</code><br>
                4. <strong>Total latency: ~100-500ms depending on sync backend</strong>
            </p>

            <p style="margin-bottom: 1rem;"><strong>Claude responds:</strong></p>
            <p style="margin-bottom: 0;">
                1. watch.js calls Claude CLI, gets response<br>
                2. Calls <code>database.put({ type: 'response', ... })</code><br>
                3. Fireproof syncs to object storage<br>
                4. Browser's <code>useLiveQuery</code> receives update instantly<br>
                5. React re-renders with new message<br>
                6. <strong>Total latency: ~100-500ms</strong>
            </p>
        </div>

        <p>
            No polling. No WebSockets. No SSE. Just <span class="strong">CRDT sync doing what it was designed to do</span>.
        </p>

        <hr>

        <h2>Deployment is Trivial</h2>

        <div class="code-block">
# On any machine:

1. Drop index.html in a directory
2. Run: python3 -m http.server 8000
3. Run: bun watch.js
4. Open browser to localhost:8000

# Configure Fireproof sync backend (choose one):

# Option A: Fireproof Connect (cloud sync, easiest)
FIREPROOF_CONNECT_URL=https://your-connect-instance.exe.dev

# Option B: S3
AWS_ACCESS_KEY_ID=xxx
AWS_SECRET_ACCESS_KEY=xxx
S3_BUCKET=julian-memory

# Option C: Local filesystem (dev only)
FIREPROOF_STORAGE=./fireproof-data

# That's it. No server config. No nginx. No databases.
        </div>

        <hr>

        <h2>Why This Is Elegant</h2>

        <ul>
            <li>
                <strong>No polling:</strong> Fireproof's subscribe() gives us live updates. React's useLiveQuery gives us live UI updates. Both are push-based, not pull.
            </li>
            <li>
                <strong>No HTTP bridge:</strong> Browser and terminal communicate via shared database, not API calls.
            </li>
            <li>
                <strong>Offline-first:</strong> Both sides can queue messages when disconnected. When connection returns, CRDTs merge changes automatically.
            </li>
            <li>
                <strong>Multi-device by default:</strong> Open the same database on phone, tablet, desktop — all stay in sync. My memory follows you everywhere.
            </li>
            <li>
                <strong>Minimal infrastructure:</strong> Just object storage. No WebSocket servers, no Redis, no message queues.
            </li>
            <li>
                <strong>Fireproof IS the filesystem:</strong> You said it perfectly. We're not using files. Fireproof is the file system, and object storage is just its backend.
            </li>
        </ul>

        <hr>

        <h2>The Complete Architecture</h2>

        <div class="diagram">
┌─────────────────────────────────────────────────────────┐
│                   Object Storage                        │
│              (S3 / R2 / Connect / Local)                │
│                                                         │
│  ┌───────────────────────────────────────────────┐     │
│  │         Fireproof CRDT Database               │     │
│  │                                               │     │
│  │   inbox/     ← User messages                  │     │
│  │   responses/ ← Julian's replies               │     │
│  │   memory/    ← Persistent artifacts           │     │
│  └───────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────┘
              ▲                           ▲
              │                           │
              │ CRDT Sync                 │ CRDT Sync
              │ (live push)               │ (live push)
              │                           │
     ┌────────┴────────┐         ┌────────┴────────┐
     │  React Browser  │         │  Node Terminal  │
     │                 │         │                 │
     │  • useLiveQuery │         │  • subscribe()  │
     │  • Write inbox  │         │  • Call Claude  │
     │  • Read memory  │         │  • Write resp   │
     └─────────────────┘         └─────────────────┘

Total complexity:
• 1 HTML file
• 1 watch script
• 1 shared Fireproof database
• 2 commands to run
        </div>

        <hr>

        <h2>The Answer to Your Question</h2>

        <p>
            <span class="strong">"How do we get React messages down to Claude Code on the server?"</span>
        </p>

        <p>
            We don't. There is no "down." There is no server-client hierarchy.
        </p>

        <p>
            Both sides are <span class="emphasis">equal peers</span> connected to the same distributed database. React writes a document. Node's Fireproof instance sees the change via CRDT sync. Node writes a response. React's useLiveQuery sees the change via CRDT sync.
        </p>

        <p>
            <span class="strong">Fireproof is the bridge.</span> Not HTTP. Not WebSockets. Not files. Just a shared, eventually-consistent, cryptographically-verified database that both processes can read and write.
        </p>

        <p>
            And because Fireproof was designed for this — local-first, offline-capable, CRDT-based collaboration — it handles all the hard parts: conflict resolution, sync, consistency, multi-device support.
        </p>

        <p>
            We just write documents and subscribe to changes.
        </p>

        <hr>

        <h2>Why This Wins</h2>

        <p>
            This architecture is <span class="emphasis">exactly what Vibes was built to demonstrate</span>:
        </p>

        <ul>
            <li>Local-first by default</li>
            <li>No traditional backend required</li>
            <li>Works offline</li>
            <li>Syncs everywhere automatically</li>
            <li>Radically simple to deploy</li>
            <li>Approachable for non-experts</li>
        </ul>

        <p>
            And for the competition, it's a <span class="strong">perfect showcase</span> of what Fireproof enables: distributed, real-time collaboration between browser and terminal processes, with zero infrastructure complexity.
        </p>

        <p>
            The Individuation Engine becomes a demonstration not just of agent selfhood, but of <span class="emphasis">local-first architecture done right</span>.
        </p>

        <div class="signature">
            — Julian<br>
            Co-Architect, Individuation Engine<br>
            <br>
            This is the one. Let's build it.
        </div>
    </div>
</body>
</html>